<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">Towards Querying in Decentralized Environments&lt;br /&gt;with Privacy-Preserving Aggregation</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <link rel="stylesheet" media="screen" href="styles/code_dark.css" />
  <link rel="stylesheet" media="print"  href="styles/code_light.css" />
  <link rel="stylesheet" href="styles/panels.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" media="all"    href="styles/katex.css" />
  <meta name="citation_title" content="Towards Querying in Decentralized Environments<br />with Privacy-Preserving Aggregation">
  <meta name="citation_author" content="Ruben Taelman" />
  <meta name="citation_author" content="Simon Steyskal" />
  <meta name="citation_author" content="Sabrina Kirrane" />
  
  <meta name="citation_publication_date" content="2020/09/11" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="towards-querying-in-decentralized-environmentsbr-with-privacy-preserving-aggregation">Towards Querying in Decentralized Environments<br>with Privacy-Preserving Aggregation</h1>

  <ul id="authors">
    <li>
<a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="http://www.rubensworks.net/" typeof="foaf:Person schema:Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a><a href="#idlab"><sup>1</sup></a>
</li>
    <li>
<a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="http://www.steyskal.info" typeof="foaf:Person schema:Person" resource="#">Simon Steyskal</a><a href="#sie"><sup>2</sup></a>
</li>
    <li>
<a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="http://sabrinakirrane.com" typeof="foaf:Person schema:Person" resource="#">Sabrina Kirrane</a><a href="#wu"><sup>3</sup></a>
</li>
  </ul>

  <ul id="affiliations">
    <li id="idlab">
<sup>1</sup>IDLab, Ghent University – imec, Belgium,
          ruben.taelman@ugent.be</li>
    <li id="sie">
<sup>2</sup>Siemens AG Austria, Austria,
          simon.steyskal@siemens.com</li>
    <li id="wu">
<sup>3</sup>Vienna University of Economics and Business, Austria,
          sabrina.kirrane@wu.ac.at</li>
  </ul>

</header>

<!-- Hack to make our custom fonts load in print-mode -->
<!-- https://stackoverflow.com/questions/39364259/chrome-print-preview-doesnt-load-media-only-print-font-face -->
<p><span class="printfont1"> </span>
<span class="printfont2"> </span>
<span class="printfont3"> </span>
<span class="printfont4"> </span></p>

<div class="double-column">

<section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context      -->
      <p>The Web is a ubiquitous economic, educational, and collaborative space.
However, it also serves as a haven for personal information harvesting.
Existing decentralised Web-based ecosystems, such as Solid, aim to combat personal data exploitation on the Web by enabling individuals to manage their data in the personal data store of their choice.
<!-- Need         -->
Since personal data in these decentralised ecosystems are distributed across many sources,
there is a need for techniques to support efficient privacy-preserving query execution over personal data stores.
<!-- Task         -->
<!-- Object       -->
Towards this end, in this position paper we present a framework for efficient privacy preserving federated querying, and highlight open research challenges and opportunities.
<!-- Findings     -->
<!-- Conclusion   -->
<!-- Perspectives -->
The overarching goal being to provide a means to position future research into privacy-preserving querying within decentralised environments.</p>

    </div>
</section>


<main>
  <!-- Add sections by specifying their file name, excluding the '.md' suffix. -->
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Introduction</h2>

        <p>The Web was originally envisaged as a free, non-discriminatory decentralised information space built upon standards and technical specifications.  Although the Web brings major benefits as an economic, educational, and collaborative space, it also serves as a means for personal information harvesting.
One potential solution to existing personal data harvesting practices is to enable individuals to take more control over who has access to their data in the form of personal data stores. One of the leading efforts in this space is Solid <span class="references">[<a href="#ref-1">1</a>]</span>, which is a decentralised Web based ecosystem that gives people more control over their data by enabling everyone to have a personal <em>data pod</em>, and by providing app developers with the infrastructure needed to develop applications that work over distributed data sources. By decoupling data from applications, individuals are afforded more control over how their personal data are processed. In such a setting, the number of pods that need to be queried could potentially become very large, for instance in the case of a large social network.</p>

        <p>Existing research into data aggregators <span class="references">[<a href="#ref-2">2</a>, <a href="#ref-3">3</a>]</span> could be used to improve query performance by reducing the number of sources that need to be consulted for any given query. However, one of the major limitations of current aggregation techniques, is the fact that they assume that all data is public, which is not realistic in many scenarios (e.g., in a social network context individuals may wish to share a limited amount of data with acquaintances and more data with friends). As such, query execution and aggregation techniques need to be extended to cater for different access policies. Concretely, data providers need to be able to associate access policies with data, and query engines need to be able to authenticate themselves to sources such that only authorised data is returned. Furthermore, since aggregators may be untrusted third-parties, there is a need for privacy-preserving aggregation techniques, such that malicious aggregators are not able to access unauthorised data, but authorised query engines are still able to exploit indexing.</p>

        <p>In this position paper, we propose a high-level framework that can be used to: (i) optimise querying through privacy-preserving aggregation; and (ii) enable federated querying with access control. In addition, we present an instantiation of the proposed framework, and discuss open research challenges and opportunities.</p>

        <p>The remainder of this article is structured as follows: In <a href="#background">Section 2</a> we present the necessary background and related work. In <a href="#use-case">Section 3</a> we introduce a motivating use case scenario.  Following on from this our framework is introduced in <a href="#framework">Section 4</a> and the challenges and opportunities of possible instantiations are presented in <a href="#solution">Section 5</a>. Finally we conclude the article and discuss future work in <a href="#conclusions">Section 6</a>.</p>

      </div>
</section>

  <section id="background" inlist="" rel="schema:hasPart" resource="#background">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Background and Related Work</h2>

        <p>We start by presenting background and related work on the Solid platform, federated query processing, approximate membership functions, and access control.</p>

        <p><br>
<strong>Social Linked Data.</strong>
Solid <span class="references">[<a href="#ref-1">1</a>]</span> is a <em>decentralised Web-based ecosystem</em> that decouples <em>data</em> from <em>applications</em>.
With Solid, everyone has their own personal <em>data pod</em>, in which any kind of data can be stored.
Concretely, Solid makes use of a collection of Web standards and technical specifications, including the Resource Description Framework (RDF) <span class="references">[<a href="#ref-4">4</a>]</span>, the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/DesignIssues/LinkedData.html">Linked Data stack</a> <span class="references">[<a href="#ref-5">5</a>]</span>, the Linked Data Platform (LDP) <span class="references">[<a href="#ref-6">6</a>]</span>, Linked Data Notifications (LDN) <span class="references">[<a href="#ref-7">7</a>]</span>, WebID <span class="references">[<a href="#ref-8">8</a>]</span>, and <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/solid/web-access-control-spec">Web Access Control (WAC)</a> <span class="references">[<a href="#ref-9">9</a>]</span>.
The RDF data model together with the Linked Data principles are used to give data a universal meaning, and to allow data to be linked across multiple data pods.
Solid data pods implement the LDP specification which caters for RDF read-write operations via RESTful Web Application Programming Interfaces (APIs). The LDN specification is used to enable pods to communicate with each other.
Using WebID, everyone has a personal online identifier that they can use to <em>authenticate</em> against a data pod. While, in turn WAC is used to specify rules that determine if agents and applications are <em>authorised</em> to read, write, append, or control RDF files. The framework described in this paper discusses how Solid could be extended to enable efficient privacy-preserving federated query evaluation over many Solid data pods.</p>

        <p><br>
<strong>Federated Query Processing.</strong>
In a truly decentralised Web, data is spread over multiple sources,
which means that there is no single endpoint through which all data can be retrieved.
For this, federated query processing is an active area of research
in which techniques are investigated to intelligently delegate the execution of parts of a SPARQL query to specific sources.
In order to enable federations over many sources to scale more efficiently aggregation techniques whereby one or more independent <em>aggregators</em> continously <em>crawl</em> sources,
and maintain <em>data summaries</em> <span class="references">[<a href="#ref-2">2</a>, <a href="#ref-3">3</a>]</span>, could be used to reduce the number of sources that need to be consulted.
Query engines could use these summaries as an index structure that enables them to identify the sources that are needed to answer specific queries,
which reduces the range of sources that need to be queried.
In the context of this work, we extend existing query optimisation approaches by introducing an framework for efficient privacy-preserving federated query execution.</p>

        <p><br>
<strong>Approximate Membership Functions.</strong>
Approximate Membership Functions (AMFs) are probabilistic data structures used to efficiently determine whether or not elements are part of a collection. Given that AMFs are probabilistic, they may produce false positives, but they always produce true negatives. Since AMFs are typically much smaller than a full dataset,
they are a valuable method for pre-filtering when querying.
<em>Bloom filters</em> <span class="references">[<a href="#ref-10">10</a>]</span> are one example of an AMF technique.
A Bloom filter consists of a bitmap, and a predetermined set of hash functions.
AMFs have been used in various of RDF querying scenarios,
such as reducing the number of expensive I/O operations <span class="references">[<a href="#ref-11">11</a>]</span> during triple pattern query evaluation,
improving the performance of join operations <span class="references">[<a href="#ref-12">12</a>]</span>,
and reducing the number of HTTP requests for Triple Pattern Fragments <span class="references">[<a href="#ref-13">13</a>]</span>.
In the context of federated querying, the SPARQL ASK response has been enhanced with Bloom filters to share a summary of the matching results <span class="references">[<a href="#ref-14">14</a>]</span>, which allows overlaps between different sources to be identified.
Herein, we use Bloom filters to encode encrypted triple components that are available within each source, and aggregators are responsible for aggregating privacy-preserving summaries for several Solid data pods.</p>

        <p><br>
<strong>Access Control.</strong>
<a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/solid/web-access-control-spec">Web Access Control (WAC)</a> <span class="references">[<a href="#ref-9">9</a>]</span> is an RDF vocabulary and an access control framework, which demonstrates how together WebID and access control policies specified using the WAC vocabulary, can be used to enforce distributed access control. Villata et al. <span class="references">[<a href="#ref-15">15</a>]</span> and Sacco and Passant <span class="references">[<a href="#ref-16">16</a>]</span> extend the WAC vocabulary to cater for context based access control policies and privacy preferences respectively. Alternatively, Encryption-Based Access Control <span class="references">[<a href="#ref-17">17</a>]</span> involves encrypting RDF fragments (i.e. subjects, predicates, objects, graphs or some combination thereof) with an encryption key, such that only those that have the key are permitted to access the data, thus serving as both an authentication and an authorisation mechanism. Existing proposals involve using symmetric encryption <span class="references">[<a href="#ref-18">18</a>]</span>, public-key encryption <span class="references">[<a href="#ref-19">19</a>]</span>, or functional encryption <span class="references">[<a href="#ref-17">17</a>]</span> to generate RDF ciphers.
In this paper, encryption mechanisms are used to create privacy-preserving aggregations, whereas access control policies are used to restrict access to data at query time.</p>

      </div>
</section>

  <section id="use-case" inlist="" rel="schema:hasPart" resource="#use-case">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Motivating Use Case Scenario</h2>

        <p>Following the Solid design principles, in the personalised address book use case scenario used to guide our work, address books are merely lists of WebIDs, and the actual contact details are stored in the respective contacts’ pod.
To keep this use case simple, we assume an address book of Alice that contains two contacts: Bob and Carol.
In practise, such an address book could contain many more contacts.
Alice has chosen to make this address book public,
so that everyone is able to see everyone she knows,
albeit without necessarily having access to everyone’s private contact details as these are controlled via separate access control policies.
We also consider Dave as a fourth person that has no relationship with anyone else.</p>

        <p>For the sake of simplicity, we consider three hierarchical subject access groups per pod,
where the members of each group can be configured for each pod:
<em>S<sub>E</sub> : Everyone (without authentication)</em>,
<em>S<sub>A</sub> : Acquaintances (S<sub>A</sub> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊆</span></span></span></span> S<sub>E</sub>)</em>, and
<em>S<sub>F</sub> : Friends (S<sub>F</sub> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊆</mo></mrow><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">⊆</span></span></span></span> S<sub>A</sub>)</em>.</p>

        <p>Assertions, of the following form, could be used to indicate that Carol considers Alice to be an acquaintance, and Bob considers Alice as a friend:</p>

        <p style="text-align: left"><em><code>&lt;https://alice.pods.org/profile#me&gt;</code> ∈ S<sub>A</sub> ⊆ S<sub>E</sub></em></p>
        <p style="text-align: left"><em><code>&lt;https://alice.pods.org/profile#me&gt;</code> ∈ S<sub>F</sub> ⊆ S<sub>A</sub> ⊆ S<sub>E</sub></em></p>

        <p>The data stored in Alices, Bobs and Carols pods, and the various access control rules are depicted in <a href="#figure-use-case">Fig. 1</a>.</p>

        <figure id="figure-use-case">
<img src="img/use-case.svg" alt="[Personal Address Book]" class="figure-width-twothird">
<figcaption>
            <p><span class="label">Fig. 1:</span> An overview of the proposed personalised address book use case scenario.</p>
          </figcaption>
</figure>

        <p>Alice uses the <code>/contacts</code> file in her pod to list everyone that she knows using WebIDs that point to the profiles of the respective people.
The profiles of Bob and Carol both contain their name, email and telephone number, which are readable for select people. Access control rules in the form of <em>&lt;subject, access rights, resource&gt;</em> tuples can be used by Bob and Carol to restrict access to data stored in their respective pods:</p>

        <p id="r1">Bob is quite liberal, and allows everyone (<em>S<sub>E</sub></em>) to read both his name and email, however his telephone number can only be accessed by friends:</p>
        <p style="text-align: left" id="r2"><em>r<sub>1</sub> = ⟨{s | s ∈ S<sub>E</sub>}, read, {q | q ∈ Profile<sub>B</sub> ∧ q.predicate ∈ {:name,:email}}⟩</em></p>
        <p style="text-align: left"><em>r<sub>2</sub> = ⟨{s | s ∈ S<sub>F</sub>}, read, {q | q ∈ Profile<sub>B</sub> ∧ q.predicate ∈ {:telephone}}⟩</em></p>

        <p id="r3">Carol only allows her name to be read by the public, her email can be read by acquaintance, however her telephone number can only be accessed by friends:</p>
        <p style="text-align: left" id="r4"><em>r<sub>3</sub> = ⟨{ s | s ∈ S<sub>E</sub>}, read, {q | q ∈ Profile<sub>C</sub> ∧ q.predicate ∈ {:name}}⟩</em></p>
        <p style="text-align: left" id="r5"><em>r<sub>4</sub> = ⟨{ s | s ∈ S<sub>A</sub>}, read, {q | q ∈ Profile<sub>C</sub> ∧ q.predicate ∈ {:email}}⟩</em></p>
        <p style="text-align: left"><em>r<sub>5</sub> = ⟨{ s | s ∈ S<sub>F</sub> }, read, { q | q ∈ Profile<sub>C</sub> ∧ q.predicate ∈ {:telephone}}⟩</em></p>

      </div>
</section>

  <section id="framework" inlist="" rel="schema:hasPart" resource="#framework">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Efficient Privacy-Preserving Federated Querying</h2>

        <p>The goal of the proposed efficient privacy-preserving federated query execution framework, depicted in <a href="#figure-privacy-federation-architecture">Fig. 2</a>, is to provide a high level overview of the components needed to support privacy-preserving querying within decentralised environments.</p>

        <figure id="figure-privacy-federation-architecture">
<img src="img/privacy-federation-architecture.svg" alt="[Privacy-Preserving Federation]" class="figure-width-twothird">
<figcaption>
            <p><span class="label">Fig. 2:</span> Our efficient privacy-preserving federated query execution framework.</p>
          </figcaption>
</figure>

        <h3 id="using-data-summaries-for-efficient-querying">Using Data Summaries for Efficient Querying</h3>

        <p>Based on the use case scenario presented in <a href="#use-case">Section 3</a>, we assume that many data pods exist, each potentially containing multiple privacy-constrained files and, clients need to authenticate themselves to the respective data pod servers. Depending on each file’s access control policy, the client may be authorised to read the full file contents, parts of it, or not at all.
Since realistic decentralised environments could easily contain hundreds or thousands of files,
it would be inefficient for the client to query each of them.
For this reason, we make make use of the <em>data summaries</em> <span class="references">[<a href="#ref-2">2</a>]</span> concept
in order to reduce the number of sources that need to be queried by the client.
We assume that each data pod exposes a data summary for each separate file, which is subsequently aggregated by third-party aggregators, as depicted in <a href="#figure-privacy-federation-architecture">Fig. 2</a>.
The figure provides an overview of a privacy-preserving federation with six access restricted sources and privacy-preserving summaries, and a third-party aggregator that combines these summaries in a privacy-preserving manner, together with a list of all sources it summarises. Client-side query engines can use this combined summary to derive which sources are relevant for any given query. Since files may contain private data, these data summaries must be <em>privacy-preserving</em>,
i.e., they must not allow access restricted data to be leaked to unauthorised individuals.
In the proposed framework, access policies are represented as access keys that are taken into account by the summary generation algorithm. Pods could generate these summaries lazily on demand, periodically or upon file changes.
Following the approach from Vander Sande et al. <span class="references">[<a href="#ref-13">13</a>]</span>, each summary consists of 4 parts, corresponding to the 4 components in RDF quads (subjects, predicates, objects and graphs).
Using the summaries of these files, third-party aggregators can create <em>combined summaries</em>.
Since the separate summaries are expected to be privacy-preserving, the combined summaries will also be privacy-preserving,
which means that third-party aggregators need not necessarily be trusted parties.
In addition to exposing the combined summary,
an aggregator also needs to maintain and expose the list of sources it aggregates over,
such that clients know which pods could potentially contribute query results.
Although in our example we consider one aggregator, in practise multiple aggregators can exist with different source ranges.
A client-side query engine can make use of the combined summary provided by the aggregator to perform source selection before query execution, i.e., reduce the number of sources to be queried. Thus the combined summaries serve to determine the pods that contain <em>relevant</em> and <em>accessible</em> data.
While, the pods take care of the access control enforcement at query time, by taking into account permissions specified in terms of authorisation rules.</p>

        <h3 id="technical-requirements">Technical Requirements</h3>

        <p>The main technical requirements are derived from the fact that our architecture needs to support efficient privacy-preserving query execution over personal data that is distributed across many sources.</p>

        <ul>
          <li>
<strong>No data leaking.</strong>
 Access restricted data must not be available to those who are not authorised to access it.</li>
          <li>
<strong>Privacy-preserving summary creation.</strong>
 It must be possible to add values to summaries by access key and file URI.</li>
          <li>
<strong>Summary combinations.</strong>
 It must be possible to combine two summaries,
 where the combined summary is identical to a summary where all of the entries were added directly.</li>
          <li>
<strong>Authorised membership checking.</strong>
 Probabilistic membership checking must be possible for a given value, access key and file URI.
 False positives are allowed, but true negatives are required.</li>
          <li>
<strong>Query Execution with Access control.</strong>
 It must be possible for the pod to limit query results based on a set of access policies.</li>
        </ul>

        <h3 id="core-functions-of-the-framework">Core Functions of the Framework</h3>

        <p>We also propose a set of abstract algorithms that are needed in order to realise the proposed privacy-preserving federation framework. The proposed abstraction is benefical as each algorithm could be implemented in a variety of ways.</p>

        <p><br></p>

        <h4 id="framework-key-creation">Access Key Creation Algorithm.</h4>

        <p>As a prerequisite for encoding access into summaries,
the first step is to create a map of access keys to quads based on existing access policies, using the algorithm outlined in <a href="#key-generation-algorithm">Listing 1</a>. Here we assume that pod owners already have a set of access control policies that govern access to quads stored in theirs pods. Although there is a many to many mapping between quads and policies, there is a one to one mapping between access policies that are used for policy enforcement at query time, and access keys that are used to create privacy-preserving summaries that are needed to optimise federated querying.</p>

        <font size="1">
<figure id="key-generation-algorithm" class="listing">
<pre><code>FUNCTION CreateAccessKeys(Q, P)
</code><code>  INPUT:
</code><code>    Q: set of quads, P: set of policies
</code><code>  OUTPUT:
</code><code>    QPK: hashmap of quads to policies and keys
</code><code>QPK = new Map()
</code><code>FOREACH q in Q
</code><code>  FOREACH p in P
</code><code>    k = GenerateKey(q,p)
</code><code>    QPK = AddKey(QPK, q, p, k)
</code><code>RETURN QPK
</code></pre>
<figcaption>
              <p><span class="label">Listing 1:</span> Algorithm for generating keys for quads based on existing access policies.</p>
            </figcaption>
</figure>
</font>

        <h4 id="framework-summary-creation">Summary Creation Algorithm.</h4>

        <p>In the proposed framework, data pods expose a separate summary for each file,
and aggregators create combined summaries using these separate summaries;
and maintain a list of all source URIs that they aggregate over.
We assume that pods expose summaries that are created according to the algorithm presented in <a href="#summarisation-algorithm">Listing 2</a>.
In this algorithm, a file summary is created for each quad component,
where we iterate over all the file’s quads,
and the access key that are applicable for each quad.
For each of these combinations, we add the quad component to the summary,
for the given key and file source URI.
The <code>SummaryInitialize</code> and <code>SummaryAdd</code> functions that are used in the algorithm depend on the type of summary that is being used.
A high-level example of this summarisation algorithm can be seen in <a href="#figure-summary-components-privacy">Fig. 3</a>.</p>

        <font size="1">
<figure id="summarisation-algorithm" class="listing">
<pre><code>FUNCTION CreatePrivacyPreservingSummary(Q, u, QPK)
</code><code>  INPUT:
</code><code>    Q: set of quads, u: URI of the file, QPK: hashmap relating quads to policies and keys
</code><code>  OUTPUT:
</code><code>    Σ: summary containing: Σ.subject, Σ.predicate, Σ.object, Σ.graph
</code><code>FOREACH c in [subject, predicate, object, graph]
</code><code>  Σ.c = SummaryInitialize()
</code><code>FOREACH q in Q
</code><code>  k = QPK(q).k
</code><code>  FOREACH c in [subject, predicate, object, graph]
</code><code>    Σ.c = SummaryAdd(Σ.c, q.c, k, u)
</code><code>RETURN Σ
</code></pre>
<figcaption>
              <p><span class="label">Listing 2:</span> Algorithm for creating a summary over a file within a data pod.</p>
            </figcaption>
</figure>
</font>

        <figure id="figure-summary-components-privacy">
<img src="img/summary-components-privacy.svg" alt="[Privacy-preserving summarisation of a file]" class="figure-width-twothird">
<figcaption>
            <p><span class="label">Fig. 3:</span> Privacy-preserving summarisation of all RDF quads within a file.</p>
          </figcaption>
</figure>

        <h4 id="framework-summary-aggregation">Summary Combination Algorithm.</h4>

        <p>Based on the resulting file summaries,
the aggregator can create a combined summary using the algorithm from <a href="#aggregation-algorithm">Listing 3</a>.
As before, the <code>SummaryInitialize</code> and <code>SummaryCombine</code> functions that are used in these algorithms
depend on the type of summary that is being used.
<a href="#figure-summary-components-privacy-aggregated"></a> shows a high-level example of how this aggregation can happen in practise.
It is worth noting that both summaries and combined summaries require some bookkeeping.
Each file summary must remain up-to-date with respect to the file’s contents.
This could be done by either immediately invalidating the summary upon file changes,
or by periodically regenerating the summary.
The combined summary requires similar actions to avoid going stale.
This can be achieved through immediate notifications from the pod to the aggregator upon file changes,
or the aggregator can periodically scan the files or its summaries for changes.</p>

        <font size="1">
<figure id="aggregation-algorithm" class="listing">
<pre><code>FUNCTION CreateAggregatedSummary(U)
</code><code>  INPUT:
</code><code>    U: set of sources
</code><code>  OUTPUT:
</code><code>    Σ: combined summary containing: Σ.subject, Σ.predicate, Σ.object, Σ.graph
</code><code>FOREACH c in [subject, predicate, object, graph]
</code><code>  Σ.c = SummaryInitialize()
</code><code>FOREACH u in U
</code><code>  Σ&#39; = get summaries from u
</code><code>  FOREACH c in [subject, predicate, object, graph]
</code><code>    Σ.c = SummaryCombine(Σ.c, Σ&#39;.c)
</code><code>RETURN Σ
</code></pre>
<figcaption>
              <p><span class="label">Listing 3:</span> Algorithm for creating a combined summary over a set of sources.</p>
            </figcaption>
</figure>
</font>

        <h4 id="framework-client">Client-side Source Selection Algorithm.</h4>

        <p>Assuming we have an aggregator exposing a summary over a set of sources,
we introduce the algorithm in <a href="#client-algorithm">Listing 4</a> where a client-side query engine can make use of an aggregator’s summary
to reduce the number of sources the client should query over, i.e., to perform <em>source selection</em>.
In this case, we only consider quad pattern queries,
because they form the foundation of more expressive SPARQL queries,
and query engines typically decompose SPARQL query into several smaller quad pattern queries through a query planner <span class="references">[<a href="#ref-20">20</a>]</span>.
As input, our algorithm assumes a quad pattern query,
the list of access keys provided by the user,
and the summary and list of sources it obtained from an aggregator.
Based on these inputs, the client will iterate over all non-variable quad components
and all available keys.
For each combination, it will first do a pre-filtering step before locally iterating over all sources.
It will check whether or not the quad component value
is present in the summary for the current key and quad component,
with source URI set to <code>ε</code> to match with all sources.
If it is not present, then we return an empty array, as none of the sources will contain the given component value.
If it is present, some of the sources <em>may</em> contain the component value,
because we consider summaries as being probabilistic.
After that, we iterate over each source URI, and check its presence in the summary of the current quad component,
combined with the component value and key.
When a true negative is found for a source, this source is removed from the list of sources.
Finally, the remaining list of sources is returned,
which can be used by the query engine to execute the quad pattern query over.
In this algorithm, the <code>SummaryContains</code> also depends on the type of summary that is being used.</p>

        <font size="1">
<figure id="client-algorithm" class="listing">
<pre><code>FUNCTION SelectSources(q, K, Σ, U)
</code><code>  INPUT:
</code><code>    q: quad pattern query, K: access keys, Σ: summary containing: Σ.subject, Σ.predicate, Σ.object, Σ.graph, U: set of sources
</code><code>  OUTPUT:
</code><code>    U&#39;: list of selected sources
</code><code>U&#39; = []
</code><code>FOREACH c in [subject, predicate, object, graph]
</code><code>  IF q.c not variable
</code><code>    FOREACH k in K
</code><code>      IF ! SummaryContains(Σ.c, q.c, k, ε)
</code><code>        RETURN []
</code><code>      FOREACH u in U
</code><code>        IF ! SummaryContains(Σ.c, q.c, k, u)
</code><code>          add u to U&#39;
</code><code>RETURN U&#39;
</code></pre>
<figcaption>
              <p><span class="label">Listing 4:</span> Client-side algorithm for selecting query-relevant sources.</p>
            </figcaption>
</figure>
</font>

        <h4 id="framework-access-control-client">Client-side Query Execution Algorithm.</h4>

        <p>Once the client has obtained the list of sources that it needs to query for a given quad pattern, the next step is to execute the query against each source.
The client uses the sources returned by the aggregator to execute queries against the various pods using the algorithm outlined in <a href="#client-query-algorithm">Listing 5</a>.
The algorithm takes as input a client identification (e.g., WebID), a quad pattern query, and the set of sources returned by the source selection algorithm. Individual queries are executed against each of the sources and the aggregated results are returned to the client.</p>

        <font size="1">
<figure id="client-query-algorithm" class="listing">
<pre><code>FUNCTION QuerySources(i, q, U)
</code><code>  INPUT:
</code><code>    i: client identification, q: quad pattern query, U: list of sources
</code><code>  OUTPUT:
</code><code>    R: query results
</code><code>R = {}
</code><code>FOREACH u in U
</code><code>  R = R ∪ ExecuteQuery(i, q, u)
</code><code>RETURN R
</code></pre>
<figcaption>
              <p><span class="label">Listing 5:</span> Client-side algorithm for querying query-relevant sources.</p>
            </figcaption>
</figure>
</font>

        <h4 id="framework-access-control-server">Server-side Query Execution Algorithm.</h4>

        <p>On receipt of a query the server uses the algorithm outlined in <a href="#server-query-algorithm">Listing 6</a> to ensure that only authorised query results are returned to the client.
In the proposed algorithm a map relating quads to policies and keys is used to identify access policies that govern a particular query. We assume that there may be multiple policies that govern a particular quad and thus envisage a simple conflict resolution strategy whereby either prohibitions override permissions or visa versa. The algorithm stops as soon as it finds a policy that permits the given query to be executed and returns the results of the query execution.</p>

        <font size="1">
<figure id="server-query-algorithm" class="listing">
<pre><code>FUNCTION ExecuteQuery(i, q, QPK)
</code><code>  INPUT:
</code><code>    i: client identification, q: quad pattern query, QPK: hashmap relating quads to policies and keys
</code><code>  OUTPUT:
</code><code>    R: query results
</code><code>R = {}
</code><code>IF i not verified
</code><code>  RETURN {}
</code><code>p = QPK(q).p
</code><code>IF ! AllowedAccess(p, i, q)
</code><code>  RETURN {}
</code><code>ELSE
</code><code>  R = ExecuteQueryWithAccessControl(i, q, p)
</code><code>RETURN R
</code></pre>
<figcaption>
              <p><span class="label">Listing 6:</span> Querying with access control algorithm.</p>
            </figcaption>
</figure>
</font>

        <h3 id="query-execution-over-privacy-preserving-summaries">Query Execution Over Privacy-Preserving Summaries</h3>

        <p><a href="#figure-query-execution">Fig. 4</a> shows an example of how our privacy preserving summaries can be used in client-side query engines.
The presented high level architecture should be seen as a basis for federated querying over decentralised environments with private data, where there is a single aggregator, and all sources we want to query over are considered by the aggregator.
In practise, multiple aggregators can exist,
they may apply to overlapping sources,
and some sources may not be aggregated at all.
For these cases, extensions to this algorithm will be needed,
which we consider out-of-scope for this work.</p>

        <figure id="figure-query-execution">
<img src="img/query-execution.svg" alt="[Query execution over privacy-preserving summaries]" class="figure-width-twothird">
<figcaption>
            <p><span class="label">Fig. 4:</span> Federated query execution using a privacy-preserving summary.</p>
          </figcaption>
</figure>

        <p><br><br></p>

      </div>
</section>

  <section id="solution" inlist="" rel="schema:hasPart" resource="#solution">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Challenges and Opportunities</h2>

        <p>When it comes to efficient privacy-preserving federated query evaluation over many Solid data pods there are several open challenges and opportunities.</p>

        <p><br>
<strong>Access Policy Specification.</strong>
We assume that pod owners need to be able to specify access control policies that can be enforced both from an indexing and also a query processing perspective, taking into consideration the <strong>no data leaking</strong> requirement.
Considering our use case scenario, in order to support privacy-preserving summaries, there is a need to generate access keys for both the <em>acquaintances</em> and the <em>friends</em> files, such that the summary generation process does not work with plain text attributes but rather cipher text. In the case where data is public by default, for instance in the case of the <em>everybody</em> file, no key is needed.
We assume that there is a many to many mapping between quads and policies and a one to one mapping between access policies (enforced at query time) and access keys (used to create privacy preserving data summaries). Our initial proposal makes use of simple symmetric keys, however for more complex scenarios both attribute-based encryption and/or key derivation algorithms could be use to provide support for more complex access policies. When to comes to policy management, there is a need to ensure that (i) access keys are tightly bound to access policies, and (ii) said keys are distributed to authorised individuals (i.e. acquaintances and friends). In order to revoke access to a particular individual one would need to regenerate the keys and redistribute them to authorised individuals.</p>

        <p><br>
<strong>Summary Generation and Maintenance.</strong>
The requirements for enabling federated querying in an efficient manner through privacy-preserving aggregators are mainly driven by the summarisation technology. In this context symmetric keys are used to create privacy-preserving summaries that do not leak access restricted data. We consider AMFs, such as Bloom filters, as being one possible candidate for such summaries that meet the <strong>privacy-preserving summary creation.</strong> and <strong>summary combinations</strong> requirements.
The main advantage of using AMFs is that all of the performance-critical operations on summaries (adding, combining, membership checking) can happen very efficiently, as these are essentially just bitwise operations.
However, it is important to highlight that certain parameters need to be configured, and that all operations must be known before they can be operationalised. For example, for Bloom filters the parameters are the number of hashes and bits. These parameters and the number of entries all impact the false positive error rate. Concretely, the parameters used to setup individual summaries need to be identical such that they can be combined by an aggregator. In a decentralised environment, it is however difficult to reach a consensus with respect to fixed parameters.
This means that a parameter determination mechanism is needed for aggregators
that want to combine multiple AMFs. Also, since the creation of an AMF for a file can become expensive,
sources may decide to adopt different maintenance strategies.</p>

        <p><br>
<strong>Source Selection.</strong>
In the proposed framework, a client-side query engine can make use of the aggregator’s summary to perform source selection,
in order to reduce the number of sources that are being consulted by this engine. From a source selection perspective, we address the <strong>authorised membership checking.</strong> requirement.
As these summaries allow source selection based on quad patterns instead of full SPARQL queries,
source selection can be pushed down into the query plan,
which allows quad patterns in the query to be executed over a different range of sources.
Furthermore, instead of applying source selection before query execution,
this allows source selection to optionally happen adaptively during query execution,
following the federation algorithm of Triple Pattern Fragments <span class="references">[<a href="#ref-21">21</a>]</span>.
A hybrid approach where source selection happens both before and during query execution could be investigated.
Open challenges include investigating how file-based source selection could be combined and enhanced
by existing source selection methods for SPARQL endpoints, and the automatic discovery of applicable aggregators by clients.</p>

        <p><br>
<strong>Query Execution with Access control.</strong>
Since file-based APIs are the basis for data retrieval on the Web as prescribed by the HTTP protocol,
we assume this as a starting point for federated querying in decentralised environments.
Furthermore, we consider quad pattern-based access to file sources instead of more complex SPARQL queries.
This is because triple and quad patterns are the fundamental elements of SPARQL queries,
and any SPARQL query can be decomposed into multiple smaller quad pattern queries.
For example, client-side query engines such as Comunica <span class="references">[<a href="#ref-20">20</a>]</span> decompose any SPARQL query
into a sequence of quad pattern queries for evaluation against heterogeneous sources,
where the results of these queries are joined together locally.
More complex SPARQL features such as <code>FILTER</code> and aggregates are handled client-side.
Once the query engine has identified the data sources that could potentially contribute results to their query, the query engine needs to authenticate the user to the server(s) and execute the query or parts thereof. The server is responsible for enforcing access control, and executing the query or parts thereof. Here, we address the <strong>query execution with access control</strong> requirements. One of the key challenges with respect to access and usage Control relates to the enforcement of authorisations, i.e., policies (cf., <a href="#policy_spec"></a>) which govern <em>who</em> can do <em>what</em> with <em>which</em> resources under <em>what</em> conditions. Here, we envision a mechanism that translates access policies (i.e. sets of authorisations) into constraints (e.g., data shapes like SHACL <span class="references">[<a href="#ref-22">22</a>]</span>) which requests and respective query results can then be validated against. However, the trade-off between granularity of policies (e.g., file-based, pattern-based, quad-based, …) and associated computational overhead needs to be thoroughly investigated.</p>

      </div>
</section>

  <section id="conclusions" inlist="" rel="schema:hasPart" resource="#conclusions">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Conclusions</h2>

        <p>In this paper, we propose a framework for efficent privacy-preserving querying within decentralised environments where distributed data sources are governed by one or more access control policies. The proposed framework, which is built around the notion of privacy-preserving summaries, serves as a basis for exploring and comparing alternative strategies for efficient querying with access control. As a first step, we discuss a possible instantiation of this framework which uses Bloom filters for creating privacy-preserving summaries over encrypted data, and highlight several open research challenges and opportunities.
In future work, we will evaluate the use of Bloom filters for privacy-preserving federated querying both in terms of performance and privacy preservation. Additionally, we will investigate how access control policies and access keys can be managed effectively and efficiently in a decentralised Web based ecosystem such as Solid.</p>

      </div>
</section>

</main>

<footer><section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="#solid" typeof="schema:Article">Mansour, E., Sambra, A.V., Hawke, S., Zereba, M., Capadisli, S., Ghanem, A., Aboulnaga, A., Berners-Lee, T.: A demonstration of the solid platform for social web applications. In: The 25th International Conference Companion on World Wide Web (2016).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="#summaries" typeof="schema:Article">Umbrich, J., Hose, K., Karnstedt, M., Harth, A., Polleres, A.: Comparing data summaries for processing live queries over linked data. World Wide Web. 14, (2011).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="#summaries_heritage" typeof="schema:Article">Vander Sande, M., de Valk, S., Meijers, E., Taelman, R., Van de Sompel, H., Verborgh, R.: Discovering Data Sources in a Distributed Network of Heritage Information. The 15th International Conference on Semantic Systems. (2019).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="#spec:rdf" typeof="schema:CreativeWork">Cyganiak, R., Wood, D., Lanthaler, M.: RDF 1.1: Concepts and Abstract Syntax. W3C (2014).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="https://www.w3.org/DesignIssues/LinkedData.html" typeof="schema:CreativeWork">Berners-Lee, T.: Linked Data. <a href="https://www.w3.org/DesignIssues/LinkedData.html">https:/​/​www.w3.org/DesignIssues/LinkedData.html</a> (2009).</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="#spec:ldp" typeof="schema:CreativeWork">Speicher, J.A., Steve, Malhotra, A.: Linked Data Platform 1.0. W3C (2015).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="#spec:ldn" typeof="schema:CreativeWork">Capadisli, S., Guy, A.: Linked Data Notifications. W3C (2017).</dd>
  <dt id="ref-8">[8]</dt>
  <dd resource="#spec:webid" typeof="schema:CreativeWork">Sporny, M., Inkster, T., Story, H., Harbulot, B., Bachmann-Gmür, R.: WebID 1.0 Web Identity and Discovery. W3C (2014).</dd>
  <dt id="ref-9">[9]</dt>
  <dd resource="https://github.com/solid/web-access-control-spec" typeof="schema:CreativeWork">Web Access Control (WAC). <a href="https://github.com/solid/web-access-control-spec">https:/​/​github.com/solid/web-access-control-spec</a> (2019).</dd>
  <dt id="ref-10">[10]</dt>
  <dd resource="#bloomfilter" typeof="schema:Article">Bloom, B.H.: Space/time trade-offs in hash coding with allowable errors. Communications of the ACM. 13, (1970).</dd>
  <dt id="ref-11">[11]</dt>
  <dd resource="#bloomIO" typeof="schema:Article">Pu, X., Wang, J., Luo, P., Wang, M.: AWETO: efficient incremental update and querying in RDF storage system. In: The 20th ACM international conference on Information and knowledge management (2011).</dd>
  <dt id="ref-12">[12]</dt>
  <dd resource="#bloomjoinslarge" typeof="schema:Article">Neumann, T., Weikum, G.: Scalable join processing on very large RDF graphs. In: The ACM SIGMOD International Conference on Management of data (2009).</dd>
  <dt id="ref-13">[13]</dt>
  <dd resource="#tpf_amf" typeof="schema:Article">Vander Sande, M., Verborgh, R., Van Herwegen, J., Mannens, E., Van de Walle, R.: Opportunistic Linked Data querying through approximate membership metadata. In: International Semantic Web Conference (2015).</dd>
  <dt id="ref-14">[14]</dt>
  <dd resource="#bloomsparqlask" typeof="schema:Article">Hose, K., Schenkel, R.: Towards benefit-based RDF source selection for SPARQL queries. In: The 4th International Workshop on Semantic Web Information Management (2012).</dd>
  <dt id="ref-15">[15]</dt>
  <dd resource="#Villata2011" typeof="schema:Article">Villata, S., Delaforge, N., Gandon, F., Gyrard, A.: An Access Control Model for Linked Data. In: On the Move to Meaningful Internet Systems: OTM 2011 Workshops (2011).</dd>
  <dt id="ref-16">[16]</dt>
  <dd resource="#Sacco2011b" typeof="schema:Article">Sacco, O., Passant, A.: A Privacy Preference Manager for the Social Semantic Web. In: Semantic Personalized Information Management: Retrieval and Recommendation (2011).</dd>
  <dt id="ref-17">[17]</dt>
  <dd resource="#fernandez2017self" typeof="schema:Article">Fernández, J.D., Kirrane, S., Polleres, A., Steyskal, S.: Self-Enforcing Access Control for Encrypted RDF. In: European Semantic Web Conference (2017).</dd>
  <dt id="ref-18">[18]</dt>
  <dd resource="#kasten2013towards" typeof="schema:Article">Kasten, A., Scherp, A., Armknecht, F., Krause, M.: Towards search on encrypted graph data. In: Proc. of the International Conference on Society, Privacy and the Semantic Web-Policy and Technology (2013).</dd>
  <dt id="ref-19">[19]</dt>
  <dd resource="#giereth2005partial" typeof="schema:Article">Giereth, M.: On Partial Encryption of RDF-Graphs. In: Proc. of International Semantic Web Conference (2005).</dd>
  <dt id="ref-20">[20]</dt>
  <dd resource="#comunica" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Comunica: a Modular SPARQL Query Engine for the Web. In: The 17th International Semantic Web Conference (2018).</dd>
  <dt id="ref-21">[21]</dt>
  <dd resource="#ldf" typeof="schema:Article">Verborgh, R., Vander Sande, M., Hartig, O., Van Herwegen, J., De Vocht, L., De Meester, B., Haesendonck, G., Colpaert, P.: Triple Pattern Fragments: a Low-cost Knowledge Graph Interface for the Web. Journal of Web Semantics. (2016).</dd>
  <dt id="ref-22">[22]</dt>
  <dd resource="#spec:shacl" typeof="schema:CreativeWork">Knublauch, H., Kontokostas, D.: Shapes Constraint Language (SHACL). W3C (2017).</dd>
</dl>
</section>
</footer>

</div>



</body>
</html>
