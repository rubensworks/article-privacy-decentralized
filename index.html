<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">Towards Querying in Decentralized Environments&lt;br /&gt;with Privacy-Preserving Aggregation</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <link rel="stylesheet" media="screen" href="styles/code_dark.css" />
  <link rel="stylesheet" media="print"  href="styles/code_light.css" />
  <link rel="stylesheet" href="styles/panels.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" media="all"    href="styles/katex.css" />
  <meta name="citation_title" content="Towards Querying in Decentralized Environments<br />with Privacy-Preserving Aggregation">
  <meta name="citation_author" content="Ruben Taelman" />
  <meta name="citation_author" content="Simon Steyskal" />
  <meta name="citation_author" content="Sabrina Kirrane" />
  
  <meta name="citation_publication_date" content="2020/05/05" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="towards-querying-in-decentralized-environmentsbr-with-privacy-preserving-aggregation">Towards Querying in Decentralized Environments<br>with Privacy-Preserving Aggregation</h1>

  <ul id="authors">
    <li>
<a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="http://www.rubensworks.net/" typeof="foaf:Person schema:Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a><a href="#idlab"><sup>1</sup></a>
</li>
    <li>
<a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="http://www.steyskal.info" typeof="foaf:Person schema:Person" resource="#">Simon Steyskal</a><a href="#sie"><sup>2</sup></a>
</li>
    <li>
<a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="http://sabrinakirrane.com" typeof="foaf:Person schema:Person" resource="#">Sabrina Kirrane</a><a href="#wu"><sup>3</sup></a>
</li>
  </ul>

  <ul id="affiliations">
    <li id="idlab">
<sup>1</sup>IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec,
          ruben.taelman@ugent.be</li>
    <li id="sie">
<sup>2</sup>Siemens AG Austria,
          Vienna, Austria,
          simon.steyskal@siemens.com</li>
    <li id="wu">
<sup>3</sup>Vienna University of Economics and Business,
          Vienna, Austria,
          sabrina.kirrane@wu.ac.at</li>
  </ul>

</header>

<!-- Hack to make our custom fonts load in print-mode -->
<!-- https://stackoverflow.com/questions/39364259/chrome-print-preview-doesnt-load-media-only-print-font-face -->
<p><span class="printfont1"> </span>
<span class="printfont2"> </span>
<span class="printfont3"> </span>
<span class="printfont4"> </span></p>

<div class="double-column">

<section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context      -->
      <p>The Web as we know it is a ubiquitous economic, educational, and collaborative space.
However, it also serves as a haven for personal information harvesting, disinformation, and political manipulation.
Existing decentralized Web-based ecosystems, such as Solid,
aim to combat personal data exploitation on the Web by giving individuals more control over their data.
<!-- Need         -->
Since personal data in these ecosystems is distributed across many sources,
there is an urgent need for techniques support efficient privacy-preserving query execution over such personal data.
<!-- Task         -->
<!-- Object       -->
Towards this end, in this paper we present a framework that can be used
to assess the effectiveness of alternative strategies for efficient federated querying with access control.
<!-- Findings     -->
In addition, we present a theoretical instantiation of the proposed framework, and discuss open research challenges and opportunities.
<!-- Conclusion   -->
<!-- Perspectives -->
Our framework will provide a basis for positioning future research into privacy-preserving querying within decentralized environment.</p>

    </div>
</section>


<main>
  <!-- Add sections by specifying their file name, excluding the '.md' suffix. -->
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Introduction</h2>

        <p>The Web was originally envisaged as a free, non-discriminatory decentralized information space built upon universal standards.  Although the Web brings major benefits as an economic, educational, and collaborative space, it also serves as a means for personal information harvesting, disinformation, and political manipulation. Additionally, in recent years, the Web has been dominated by a handful of centralized service providers commonly known as Google, Amazon, Facebook, Apple, or simply the GAFA.</p>

        <p>One potential solution to the existing problems is to enable individuals to take more control over their data in the form of personal data stores and to provide infrastructure that supports decentralised query processing. One of the leading efforts in this space is Solid <span class="references">[<a href="#ref-1">1</a>]</span>, which is a decentralized Web-based ecosystem that gives people more control over their data by enabling everyone to have a personal <em>data pod</em> to store their data, and by providing app developers with the infrastructure needed to develop applications that work over distributed data sources. By decoupling data from applications, individuals are afforded more control over how their personal data are processed. However, the number of data sources that need to be queried could potentially become very large, for instance in the case of a large social network. Thus giving rise to research into data aggregators <span class="references">[<a href="#ref-2">2</a>]</span> that can be used to improve query performance by reducing the number of sources that need to be requested for any given query.</p>

        <p>One of the major limitations of current aggregation techniques, is the fact that they assume that all data is public, which is not realistic in many scenarios (e.g., in a social network context individuals may only wish to share a limited amount of data with acquaintances, while at the same time being able to share more data with friends). As such, query execution and aggregation techniques need to be extended to enable them to work with different access policies.</p>

        <p>Concretely, query engines need to be able to authenticate themselves to sources, such that only authorised data is returned. Furthermore, since aggregators may be untrusted third-parties, there is a need for privacy-preserving aggregation techniques, such that malicious aggregators are not able to access unauthorised data, but authorized query engines are still able to exploit them.</p>

        <p>In this position paper, we propose a high-level framework that can be used to: (i) optimize federated querying through privacy-preserving aggregation; and (ii) enable federated querying with access control. <!--Our goal is *not* to introduce a complete solution to these problems, instead, our contribution is a framework that can be used to position future research.--></p>

        <p>The remainder of this article is structured as follows: In <a href="#background">Section 2</a> we present relevant background in terms of querying and indexing.
In <a href="#use-case">Section 3</a> we introduce the motivating use case that is used to guide our work.  Following on from this our framework is introduced in <a href="#framework">Section 4</a> and a possible instantiation is presented in <a href="#solution">Section 5</a>.
Finally we conclude the article and discuss future work in <a href="#conclusions">Section 6</a>.</p>

      </div>
</section>

  <section id="background" inlist="" rel="schema:hasPart" resource="#background">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Background and Related Work</h2>

        <p>Before describing our motivating scenario and introducing our privacy-preserving federation framework, we first present the necessary background information in relation to the Solid platform, federated query processing, approximate membership functions, authentication and authorisation.</p>

        <!-- the W3C Shapes Constraint Language (SHACL). -->

        <h3 id="solid">Solid</h3>

        <p>Solid <span class="references">[<a href="#ref-1">1</a>]</span> is a <em>decentralized Web-based ecosystem</em> that decouples <em>data</em> from <em>applications</em>.
With Solid, everyone has their own personal <em>data pod</em>, in which any kind of data can be stored.
Applications are decoupled from the data, and require permission from users to access their personal data store.
Individuals can decide which actors and applications can read from or write to specific parts of their data store.</p>

        <p>Solid is not an application or tool, but rather a collection of open standards and conventions.
Concretely, Solid makes use of a collection of Web standards, including the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/">Resource Description Framework</a> <span class="references">[<a href="#ref-3">3</a>]</span>, the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/DesignIssues/LinkedData.html">Linked Data stack</a> <span class="references">[<a href="#ref-4">4</a>]</span>, the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/ldp/">Linked Data Platform (LDP)</a> <span class="references">[<a href="#ref-5">5</a>]</span>, <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/ldn/">Linked Data Notifications (LDN)</a> <span class="references">[<a href="#ref-6">6</a>]</span>, <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/2005/Incubator/webid/spec/identity/">WebID</a> <span class="references">[<a href="#ref-7">7</a>]</span>, and <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/solid/web-access-control-spec">Web Access Control (WAC)</a> <span class="references">[<a href="#ref-8">8</a>]</span>.
The RDF data model together with the Linked Data principles are used to give data a universal meaning through URIs, and to allow data to be linked across multiple data pods.
Solid data pods are assumed to implement the LDP specification to allow read-write RDF through a RESTful Web API.
Solid also allows non-RDF data, such as plain text or images, to be stored in data pods,
but these can only be managed through the usual HTTP methods such as GET and PUT.
The LDN specification, which defines how messages can be sent between two agents as Linked Data, is used to enable pods to communicate with each other.
Finally using WebID, everyone has a personal online identifier which they can use to <em>authenticate</em> against a data pod, while WAC, is used to specify if they are <em>authorised</em> to read, write, append, or control RDF files.</p>

        <!-- Make a simple overview figure of the specs in Solid and how they work together?
{:.todo} -->

        <h3 id="federated-query-processing">Federated Query Processing</h3>

        <p>In a truly decentralized Web, data is spread over multiple sources,
which means that there is no single <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/">endpoint</a> <span class="references">[<a href="#ref-9">9</a>]</span> through which all data can be retrieved.
For this, <em>federated query processing <span class="references">[<a href="#ref-10">10</a>]</span></em> is an active area of research
in which techniques are investigated to intelligently delegate the execution of parts of <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/">SPARQL queries</a> <span class="references">[<a href="#ref-11">11</a>]</span> to specific sources.
To make such federations over many sources scale better, aggregation techniques,
whereby one or more independent <em>aggregators</em> continously <em>crawl</em> sources,
and maintain <em>data summaries <span class="references">[<a href="#ref-2">2</a>, <a href="#ref-12">12</a>]</span></em>, could be used to reduce the number of sources that need to be consulted.
Query engines could then make use of such summaries as an index structure to identify
which sources are relevant for specific queries,
which reduces the range of sources that the query engines need to interact with.</p>

        <p>In the context of this work, we will tackle the federation over many Solid data pods.
We extend the data summary approach by introducing a privacy-preserving aggregation approach.</p>

        <h3 id="approximate-membership-functions">Approximate Membership Functions</h3>

        <p>Approximate Membership Functions (AMFs) are probabilistic data structures used to efficiently determine whether or not elements are part of a collection.
Given that AMFs are probabilistic, they may produce false positives, but they always produce true negatives.
Since AMFs are typically much smaller than a full dataset,
they are a valuable method for pre-filtering when querying.</p>

        <p><a property="schema:citation http://purl.org/spar/cito/cites" href="http://crystal.uta.edu/~mcguigan/cse6350/papers/Bloom.pdf"><em>Bloom filters</em></a> <span class="references">[<a href="#ref-13">13</a>]</span> are one example of an AMF technique.
A Bloom filter is a bitmap, and a predetermined set of hash functions.
To construct a Bloom filter, each element is run through these hash functions to produce a bit vector,
and all of these vectors are <code>OR</code>-ed into the bitmap.
To test the membership of an element, the same hash functions are applied, and their binary membership is tested.
Since Bloom filters are bitmaps, multiple Bloom filters can be merged together efficiently by <code>OR</code>-ing them.</p>

        <p>AMFs have been used in various of RDF querying scenarios,
such as <a property="schema:citation http://purl.org/spar/cito/cites" href="https://dl.acm.org/citation.cfm?doid=2063576.2063988">reducing the number of expensive I/O operations</a> <span class="references">[<a href="#ref-14">14</a>]</span> during triple pattern query evaluation,
<a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.researchgate.net/profile/Thomas_Neumann2/publication/47863714_Scalable_Join_Processing_on_Very_Large_RDF_Graphs/links/00b7d51d1687cae740000000.pdf">improving the performance of join operations</a> <span class="references">[<a href="#ref-15">15</a>]</span>,
and <a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/iswc2015-amf.pdf">reducing the number of HTTP requests for Triple Pattern Fragments</a> <span class="references">[<a href="#ref-16">16</a>]</span>.
In the context of federated querying, the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://domino.mpi-inf.mpg.de/intranet/ag5/ag5publ.nsf/0/DAAD136B50B0C0ECC12579E6004D6582/%24file/p2-hose.pdf">SPARQL ASK response has been enhanced with Bloom filters to share a summary of the matching results</a> <span class="references">[<a href="#ref-17">17</a>]</span>, which allows overlaps between different sources to be identified.</p>

        <p>In the context of our work, Bloom filters are used to encode encrypted triple components that are available within each source, and we let aggregators combine them.</p>

        <h3 id="authentication">Authentication</h3>

        <p>Authentication is the process of verifying someone is who they say they are and/or verifying someones attributes or credentials are valid. From an authentication perspective, we provide a brief overview of the predominant identity management approaches:</p>

        <p><a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/2005/Incubator/webid/spec/identity/">Web Identity and Discovery (WebID)</a> <span class="references">[<a href="#ref-7">7</a>]</span> is a HTTP URI used to uniquely identify and authenticate a person, company, organisation, or other entity <span class="references">[<a href="#ref-18">18</a>]</span>. A description of the agent is provided in an RDF document, known as a dereferencable WebID profile. The agent places the URI for their WebID profile document in the Subject Alternative Names field of their certificate and the public key details to their WebID profile document <span class="references">[<a href="#ref-19">19</a>]</span>. The WebID Transport Layer Security (TLS) protocol specifies how the WebID profile and public key certificates can together be used to authenticate users <span class="references">[<a href="#ref-19">19</a>]</span>. A service wishing to authenticate the user, needs to verify that the public key of the certificate it receives matches the public key specified in the WebID profile <span class="references">[<a href="#ref-20">20</a>]</span>.</p>

        <p><a property="schema:citation http://purl.org/spar/cito/cites" href="https://openid.net/specs/openid-connect-core-1_0.html%20">OpenID Connect</a> <span class="references">[<a href="#ref-21">21</a>]</span> is an industry standard authentication protocol, which enables applications to delegate responsibility for authentication to third party identity providers. One of the primary benefits being the ability to connect to multiple sites using the same login credentials. A comprehensive security analysis of the protocol is provided by Fett et al. <span class="references">[<a href="#ref-22">22</a>]</span>.</p>

        <p><a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.egiz.gv.at/files/download/Self-Sovereign-Identity-Whitepaper.pdf">Self-sovereign identity (SSI)</a> <span class="references">[<a href="#ref-23">23</a>]</span> is a paradigm shift in terms of identity management, whereby individuals manage their own identity credential as opposed to relying on centralised identity providers, such as private or public sector organisations. Mühle et al. <span class="references">[<a href="#ref-24">24</a>]</span> provides a high level overview of the various components that are necessary to support SSI. Key supporting technology includes, verifiable claims which has claims that can be verified via a digital signature, and blockchain technology which plays the role of the third party identity provider.</p>

        <p>Given that WebID is the default authentication mechanism for Solid, in this paper we have elected to use it for the instantiation of the proposed federated querying with policies framework. However it is worth noting that both OpenIDConnect and SSI are both viable alternatives.</p>

        <h3 id="authorisation">Authorisation</h3>

        <p>Authorisations are access control rules that specify what subjects have access to specific resources.
In this section we provide a brief overview of three different approaches that can be used to specify authorisation rules.</p>

        <p><a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/solid/web-access-control-spec">Web Access Control (WAC)</a> <span class="references">[<a href="#ref-8">8</a>]</span> is an RDF vocabulary and an access control framework, which demonstrates how together WebID and access control policies specified using the WAC vocabulary, can be used to enforce distributed access control. Essentially WAC authorisations grant agents, access to resources. Both Villata et al. <span class="references">[<a href="#ref-25">25</a>]</span> and <a property="schema:citation http://purl.org/spar/cito/cites" href="http://ceur-ws.org/Vol-781/paper6.pdf">Sacco and Passant</a> <span class="references">[<a href="#ref-26">26</a>]</span> extend the WAC vocabulary to cater for context based access control policies and privacy preferences respectively.</p>

        <p>Pattern-based Access Control is a flexible means to specify the triples that can be access. A triple pattern is composed of an RDF triple with optionally a variable (denoted by a ?) in the subject, predicate and/or object position. <a property="schema:citation http://purl.org/spar/cito/cites" href="http://dx.doi.org/10.1007/978-3-642-39218-4_6">Kirrane et al.</a> <span class="references">[<a href="#ref-27">27</a>]</span> demonstrate how authorisations based on quad patterns (where the fourth element denotes the named graph) can be used to enforce Discretionary Access Control (DAC), whereby users can pass their access rights on to other users. Typical enforcement strategies involve filtering unauthorised data based on access control policies and executing queries against the filtered dataset, or using query rewriting techniques to inject access control filters into queries.</p>

        <p>Encryption-Based Access Control involves encrypting RDF fragments (i.e. subjects, predicates, objects, graphs or some combination thereof) with an encryption key, such that only those that have the key are permitted to access the data, thus serving as both an authentication and an authorisation mechanism. Existing proposals involve using symmetric encryption <span class="references">[<a href="#ref-28">28</a>]</span>, public-key encryption <span class="references">[<a href="#ref-29">29</a>]</span>, or functional encryption <span class="references">[<a href="#ref-30">30</a>]</span> to generate RDF ciphers.</p>

        <p><em class="sidenote">if we remove the SHACL stuff, we don’t really add anything to the body of work we’ve outlined 2 paragraphs earlier (e.g. <a property="schema:citation http://purl.org/spar/cito/cites" href="http://dx.doi.org/10.1007/978-3-642-39218-4_6">Kirrane et al.</a> <span class="references">[<a href="#ref-27">27</a>]</span>) right? remove this paragraph all together?</em></p>

        <p class="sidebar-comment">In this paper we discuss how pattern-based access control policies expressed in terms of sets of authorisations can provide support for expressive access control policies beyond the simple file-based access control currently used in Solid, and demonstrate how existing encryption mechanisms can be used to create privacy-preserving aggregation.</p>

      </div>
</section>

  <section id="use-case" inlist="" rel="schema:hasPart" resource="#use-case">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">A Personalized Address Book Use Case Scenario</h2>

        <p>Before presenting our privacy-preserving federation framework we first provide a high level overview of our personalized address book use case scenario,
where the address book is merely a list of WebIDs,
and the actual details of each contact is stored in their own respective pod.
To keep this use case simple, we assume an address book of Alice that contains two contacts: Bob and Carol.
In practise, such an address book could contain many more contacts.
Alice has chosen to make this address book public,
so that everyone is able to see everyone she knows,
albeit without necessarily having access to everyone’s private contact details as these are controlled via separate access control policies.
We also consider Dave as a fourth person that has no relationship with anyone else.</p>

        <p>For the sake of simplicity, we consider three hierarchical subject groups per pod,
where the members of each group can be configured for each pod:</p>

        <ul>
          <li>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>E</mi></msub></mrow><annotation encoding="application/x-tex">S_E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: Everyone (without authentication)</li>
          <li>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">S_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: Acquaintances (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>A</mi></msub><mo>⊆</mo><msub><mi>S</mi><mi>E</mi></msub></mrow><annotation encoding="application/x-tex">S_A \subseteq S_E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</li>
          <li>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>F</mi></msub></mrow><annotation encoding="application/x-tex">S_F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>: Friends (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>F</mi></msub><mo>⊆</mo><msub><mi>S</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">S_F \subseteq S_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)</li>
        </ul>

        <!--
{::options parse_block_html="true" /}
<div class="bs-callout bs-callout-info">
  <strong>Roles, Rules and Confusion</strong>\\
  Later on (i.e., [](#access-policy-specification)) we use `R1C, R2B, etc.` to indicate `Rules` of Carol, Bob,... Also, the current description above may be focusing too much on the **Role** part, rather than roles being just one of the aspects of a policy.. What about something along the lines of:

- a policy `p` consisting of a set of rules `R` where each rule `r` is represented as \\
  a tuple `r = ⟨t, s, a, o⟩` with
  - `t ∈ {perm,proh,obl}` - specifying the `type` of the rule \*
  - `s` - the party/user/group... to which this rule applies to (WHO)
  - `a` - the action/mode/... to be executed (HOW)
  - `o` - the resource/asset/asset group/... in question (WHAT)

\* TBD → only required if we want to add the concept of _obligations_ at some point too.. otherwise, every `r` would represent an explicit permission, thus if there's no applicable rule for a request the request should be denied (prohibition)

</div>

{::options parse_block_html="false" /} -->

        <p><em class="sidenote">still not happy about the formatting 😢 looks too thick.. any ideas on how to fix that? @ruben</em></p>

        <p class="sidebar-comment"><a href="#figure-use-case">Fig. 1</a> shows a detailed overview of this use case.
Alice uses the <code>/contacts</code> file in her pod to list everyone that she knows using their WebID,
which point to the profiles of the respective people.
The profiles of Bob and Carol both contain their name, email and telephone number,
which are readable for select people.
Bob is quite liberal, and allows everyone (<code>S</code><sub><code>E</code></sub>) to read both his name and email (<code>r</code><sub><code>1</code></sub><code> = ⟨{s | s ∈ S</code><sub><code>E</code></sub><code>}, read, {q | q ∈ Profile</code><sub><code>B</code></sub> <code>∧ q.predicate ∈ {:name,:email}}⟩</code>).
His telephone number is however only readable for friends  (<code>r</code><sub><code>2</code></sub><code> = ⟨{s | s ∈ S</code><sub><code>F</code></sub><code>}, read, {q | q ∈ Profile</code><sub><code>B</code></sub> <code>∧ q.predicate ∈ {:telephone}}⟩</code>).
Bob considers Alice a friend (<code>&lt;https://alice.pods.org/profile#me&gt; ∈ S</code><sub><code>F</code></sub><code> ⊆ S</code><sub><code>A</code></sub><code> ⊆ S</code><sub><code>E</code></sub>).
Carol only allows her name to be read by the public (<code>r</code><sub><code>3</code></sub><code> = ⟨{s | s ∈ S</code><sub><code>E</code></sub><code>}, read, {q | q ∈ Profile</code><sub><code>C</code></sub> <code>∧ q.predicate ∈ {:name}}⟩</code>), her email is only readable by acquaintances (<code>r</code><sub><code>4</code></sub><code> = ⟨{s | s ∈ S</code><sub><code>A</code></sub><code>}, read, {q | q ∈ Profile</code><sub><code>C</code></sub> <code>∧ q.predicate ∈ {:email}}⟩</code>),
and her telephone number by friends  (<code>r</code><sub><code>5</code></sub><code> = ⟨{s | s ∈ S</code><sub><code>F</code></sub><code>}, read, {q | q ∈ Profile</code><sub><code>C</code></sub> <code>∧ q.predicate ∈ {:telephone}}⟩</code>).
Carol considers Alice an acquaintance (<code>&lt;https://alice.pods.org/profile#me&gt; ∈ S</code><sub><code>A</code></sub><code> ⊆ S</code><sub><code>E</code></sub>).</p>

        <p><em class="sidenote">- update rules <br><br>- Alice’s Address Book, as well as Bob’s and Carol’s respective profiles are considered being “Files” in our terminology, right? if yes, why are they coloured differently and why do profiles have the same color as summaries? imo, we should use colors of core components like summaries/pods/.. for the respective components only. <br><br>- should we move the rules from below the profile to above of it, surrounded by an <code>Access Policy</code> block like in <a href="#figure-request-processing">Fig. 11</a>?</em></p>

        <figure id="figure-use-case" class="sidebar-comment">
<img src="img/use-case.svg" alt="[Personal Address Book]" class="figure-width-twothird">
<figcaption>
            <p><span class="label">Fig. 1:</span> Overview of the personalized address book use case where Alice, Bob and Carol each have separate data pods.
Alice has an address book that contains links to the profiles of Bob and Carol.
All triples in each profile are annotated with a role for users that can read that triple.
Full lines indicate data reading by people,
and dashed lines indicate data links.</p>
          </figcaption>
</figure>

        <!--

**Bob is quite liberal, and allows everyone to read both his name and email.**

- \$$r1_B = \langle\{s\;\vert\;s \in S_E\}, read, \{o\;\vert\;o \in File_B \wedge o \subseteq \{name, email\}\}\rangle$$

**His telephone number is however only readable for friends.**

- `r2`<sub>`B`</sub> `= ⟨{s | s ∈ Friends`<sub>`C`</sub>`}, read, {o | o ∈ File`<sub>`Friends`<sub>`B`</sub></sub>`∧ o ⊆ {telephone number}⟩`

**Bob considers Alice a friend**

- `Alice ∈ S`<sub>`F`</sub>`, S`<sub>`F`</sub>`⊆ S`<sub>`A`</sub>`⊆ S`<sub>`E`</sub>
- `Alice ∈ S`<sub>`F`</sub>`, Alice ∈ S`<sub>`A`</sub>`, Alice ∈ S`<sub>`E`</sub>
- `{Alice} ⊆ S`<sub>`F`</sub>` ⊆ S`<sub>`A`</sub>`⊆ S`<sub>`E`</sub>


**Carol allows only her name to be read by the public**

- `r1`<sub>`C`</sub> `= ⟨{s | s ∈ Everyone}, read, {o | o ∈ File`<sub>`Everyone`</sub>`∧ o ⊆ name}⟩`

**Her email is only readable by acquaintances**

- `r2`<sub>`C`</sub> `= ⟨{s | s ∈ Acquaintances`<sub>`C`</sub>`}, read, {o | o ∈ File`<sub>`Acquaintances`<sub>`C`</sub></sub>`∧ o ⊆ email}⟩`

**Her telephone number is readable by friends only**

- `r3`<sub>`C`</sub> `= ⟨{s | s ∈ Friends`<sub>`C`</sub>`}, read, {o | o ∈ File`<sub>`Friends`<sub>`C`</sub></sub>`∧ o ⊆ telephone number}⟩`

**Carol considers Alice a acquaintance**

- Alice $$\in S_A\subseteq S_E$$
- Alice $$\notin S_F$$, Alice $$\in S_A$$, Alice $$\in S_E$$ -->

        <p>For this use case, we consider the following example queries:</p>

        <p><em class="sidenote">replace justifications with references to Authorization Rules</em></p>

        <ol class="sidebar-comment">
          <li>
<strong>Alice wants to send an email to everyone she knows.</strong>
<br>
Alice is able to read the email of both Bob and Carol.
Because Bob’s email is readable for everyone (<em>Alice ∈ R1<sub>B</sub></em>),
and Carol’s email is readable for acquaintances (<em>Alice ∈ R2<sub>C</sub></em>).</li>
          <li>
<strong>Alice wants to call everyone she knows.</strong>
<br>
Alice is able to read the telephone number of Bob, but not Carol.
Because Bob’s telephone number is readable for friends (<em>Alice ∈ R3<sub>B</sub></em>),
but Carol’s telephone number is only readable for her friends (<em>Alice ∉ R2<sub>C</sub></em>).</li>
          <li>
<strong>Dave wants to send an email to everyone Alice knows.</strong>
<br>
Dave is able to read the email of Bob, but not Carol.
Because Bob’s email is readable for everyone (<em>Dave ∈ R1<sub>B</sub></em>),
and Carol’s email is only readable for acquaintances (<em>Dave ∉ R2<sub>C</sub></em>).</li>
          <li>
<strong>Dave wants to call everyone Alice knows.</strong>
<br>
Dave is not able to read the telephone number of Bob or Carol.
Because Bob’s telephone number is readable for friends (<em>Dave ∉ R3<sub>B</sub></em>),
but Carol’s telephone number is only readable for her friends (<em>Dave ∉ R3<sub>C</sub></em>).</li>
        </ol>

        <p class="todo">SABRINA check use case and examples are aligned</p>

      </div>
</section>

  <section id="framework" inlist="" rel="schema:hasPart" resource="#framework">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">A Privacy-Preserving Federation Framework</h2>

        <!-- In this section, we introduce a framework to enable querying
over decentralized environments in a privacy-preserving manner,
which provides support for use cases such as the one introduced in [](#use-case).
We put a particular emphasis on three core aspects of the framework:
(i) we introduce a high-level architecture for enabling federated querying in a privacy-preserving manner;
(ii) we list the requirements for enabling fine-grained access control in decentralized environments; and
(iii) we discuss required extensions to identity management within decentralized environments. -->

        <!-- ### Privacy-Preserving Federated Querying -->

        <p>The proposed privacy-preserving federation framework is depicted in <a href="#overall-architecture">Fig. 2</a>.
We first provide a high-level overview of the framework, and the requirements that guide our proposal. Following on from this we introduce the various algorithms that are needed to enable efficient privacy-preserving federated querying.</p>

        <figure id="overall-architecture">
<img src="img/overall-architecture.svg" alt="[Privacy-Preserving Federated Querying Architecture]" class="figure-width-twothird">
<figcaption>
            <p><span class="label">Fig. 2:</span> The proposed Privacy-Preserving Federation Architecture is composed of four core entities, namely Requesters, Pods, Aggregators, and Query Engines.</p>
          </figcaption>
</figure>

        <h3 id="architecture-overview">Architecture Overview</h3>

        <p>Based on our use case from <a href="#use-case">Section 3</a>, we assume that multiple data pods exist, each potentially containing multiple privacy-constrained files.
If clients want to read the contents of these files,
they have to authenticate themselves to the respective data pod servers. Depending on each file’s access control policy, the client may be authorized to read the full file contents or parts of it.</p>

        <p>Since realistic decentralized environments could easily contain hundreds or thousands of files,
it can become inefficient for the client to query each of them.
For this reason, we make make use of the <em>data summaries <span class="references">[<a href="#ref-2">2</a>]</span></em> concept
in order to reduce the number of sources that need to be queried by the client.
We assume that each data pod exposes a data summary for each separate file, which is subsequently aggregated by third-party aggregators, as depicted in <a href="#figure-privacy-federation-architecture">Fig. 3</a>.</p>

        <figure id="figure-privacy-federation-architecture">
<img src="img/privacy-federation-architecture.svg" alt="[Privacy-Preserving Federation]" class="figure-width-twothird">
<figcaption>
            <p><span class="label">Fig. 3:</span> Overview of a privacy-preserving federation with six access restricted sources and privacy-preserving summaries,
and a third-party aggregator that combines these summaries in a privacy-preserving manner,
together with a list of all sources it summarizes.
Client-side query engines can use this combined summary to derive which sources are relevant for any given query.</p>
          </figcaption>
</figure>

        <p>Since files may contain private data, these data summaries must be <em>privacy-preserving</em>,
i.e., they must not allow access restricted data to be leaked to unauthorised individuals.
Here we assume that access policies can be represented as access keys and these keys are taken into account by the summary generation algorithm.</p>

        <p>Pods can generate these summaries lazily on demand, either periodically or upon file changes.
An overview of this architecture can be seen in <a href="#figure-privacy-federation-architecture">Fig. 3</a>.
Following the approach from <a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/iswc2015-amf.pdf">Vander Sande et al.</a> <span class="references">[<a href="#ref-16">16</a>]</span>,
each summary consists of 4 parts, corresponding to the 4 components in RDF quads,
as illustrated in <a href="#figure-summary-components">Fig. 4</a>.
This summary approach is followed because it enables querying for any possible quad pattern combination,
where quad pattern queries are the fundamental elements of SPARQL queries.</p>

        <figure id="figure-summary-components">
<img src="img/summary-components.svg" alt="[Summarization of a file]" height="150px" class="figure-width-half">
<figcaption>
            <p><span class="label">Fig. 4:</span> Summarization of all RDF quads within a file.
The summary contains 4 parts, corresponding to all subjects, predicates, objects and graphs in the file.
The <code>CreateSummary</code> implementation depends on the type of summary,
for which <a property="schema:citation http://purl.org/spar/cito/cites" href="http://linkeddatafragments.org/publications/iswc2015-amf.pdf">Vander Sande et al.</a> <span class="references">[<a href="#ref-16">16</a>]</span> provide different implementations.
<em>Note: The summary values are not necessarily an exact representation of the way the summary is stored,
these values are merely an indication of what information is used to construct the summary.</em></p>
          </figcaption>
</figure>

        <p>Similar as to how RDF triple stores such as RDF-3X <span class="references">[<a href="#ref-31">31</a>]</span>
make use of auxiliary aggregated indexes where multiple quad components are combined,
our summaries could follow a similar extension in order to reduce the number of lookups for a given quad pattern query.
Since this would however come at the cost of larger summaries,
we consider this out of scope for this work.</p>

        <p>Using the summaries of these files, third-party aggregators can create <em>combined summaries</em>.
Since the separate summaries are expected to be privacy-preserving, the combined summaries will also be privacy-preserving,
which means that third-party aggregators will not be able to know the actual contents of the data,
and they need not necessarily be trusted parties.
In addition to exposing the combined summary,
an aggregator also needs to maintain and expose the list of sources it aggregates over,
such that clients know which data sources could potentially contribute query results.
Although in our example we consider one aggregator, in practise multiple aggregators can exist with different source ranges.</p>

        <!-- This aggregation process will be explained in more detail in [](#framework-aggregation). -->

        <p>A client-side query engine can make use of the combined summary provided by the aggregator to perform source selection before query execution, i.e., reduce the number of sources to be queried. Thus the combined summaries serve to determine the data sources that contain <em>relevant</em> and <em>accessible</em> data.
Finally, the data sources take care of the access control enforcement at query time, by taking into account permissions specified in terms of authorisation rules.</p>

        <!-- For each source, it should do this by testing the summary for its query using its authentication key.
If the test is true, then the client should consider this source as valid target it can query.
This client-side process will be explained in more detail in [](#framework-client). -->

        <p class="comment" data-author="RT">We’re using a mixture of both “file” and “data source”.
We should probably stick to just one, to avoid confusion.
In the context of Solid, I think “file” makes more sense.
But we should clarify somewhere early on that we consider them equivalent.</p>

        <p class="comment" data-author="SS">Isn’t “data source” the more generic term? What if I don’t necessarily want to serve a raw file but an endpoint via my pod? could I do this too?</p>

        <h3 id="architecture-requirements">Architecture Requirements</h3>

        <p>The main technical requirements are derived from the fact that our architecture needs to support efficient privacy-preserving query execution over personal data that is distributed across many sources.
Thus we consider the following key requirements:</p>

        <!--, where `Σ.c` and `Σ'.c` denote existing summaries, `q` denotes a quad, `q.c` denotes a quad component, `p` denotes a given access policy, `k` denotes a given access key, `u` denotes the URI for the data source, `a` denotes a mode of access, and `R` denotes query execution results:-->

        <ol>
          <li>
<strong>No data leaking</strong>:
Access restricted data must not be available to those who are not authorised to access it. <!--Implementations for `GenerateKey(q,p)` and `AddKey(QPK, q, p, k)` are required to generated a key for a given access policy and create a map of quads, policies and keys.-->
</li>
          <li>
<strong>Privacy-preserving summary creation</strong>:
It must be possible to add values to summaries by access key and file URI.
<!--An implementation for `SummaryAdd(Σ.c, q.c, k, u)` is required to create the individual summaries,
based on an initialized summary as implemented by `SummaryInitialize()`.-->
</li>
          <li>
<strong>Summary combinations</strong>
It must be possible to combine two summaries,
where the combined summary is identical to a summary where all of the entries were added directly.
 <!--An implementation for `SummaryCombine(Σ.c, Σ'.c)` is required, based on an initialized summary as implemented by `SummaryInitialize()`..-->
</li>
          <li>
<strong>Authorized membership checking</strong>
Probabilistic membership checking must be possible for a given value, access key and file URI.
False positives are allowed, but true negatives are required.
<!-- We require that the file URI can be falsy, in case all file URIs must be tested. Here, an implementation for `SummaryContains(Σ.c, q.c, k, u)` is required..-->
</li>
          <li>
<strong>Access control enforcement</strong>
It must be possible for the data source to limit query results based on a set of access policies. <!--Thus there is an need for functions that identify the policies (implemented via `GetPolicies(QPK, c, q)`) that need to be considered during query execution (implemented via `ExecuteQueryWithAccessControl(c, q, p)`)..-->
</li>
        </ol>

        <p class="todo">For this last one, should we refocus it to access control enforcement on the summaries, instead of the source itself?</p>

        <p class="todo">RESPONSE: 1) No data leakage is the requirement which motivates the use of encryption to ensure summaries are privacy-preserving, whereas 5) access control enforcement is the requirement which motivates the SHACL constant execution at query time.</p>

        <p class="comment" data-author="RT">Above, the required function implementations are commented out.
Any reason for this? If not, can these be restored?</p>

        <h3 id="access-key-creation-algorithm">Access Key Creation Algorithm</h3>

        <p>The main purpose of an aggregator is to enable clients to optimize federated querying
by reducing the range of files to query over through summaries.
Since we are considering private data, these summaries need to be privacy-preserving,
which means that only people with the appropriate access rights can determine the presence of data.
The first step is to create a map of keys to quads based on existing access policies, using the algorithm outlined in <a href="#key-generation-algorithm">Listing 1</a>. Here we assume that pod owners already have a set of access control policies that govern access to quads stored in theirs pods.</p>

        <p><em class="sidenote">s/list/set/ ? or does order matter? it shouldn’t as we go over each policy (and generate an access key?) for each q ∈ Q anyway..</em></p>

        <figure id="key-generation-algorithm" class="sidebar-comment listing">
<pre><code>FUNCTION CreateAccessKeys(Q, P)
</code><code>  INPUT:
</code><code>    set of quads Q
</code><code>    set of policies P
</code><code>  OUTPUT:
</code><code>    hashmap of quads to policies and keys QPK
</code><code>QPK = new Map()
</code><code>FOREACH q in Q
</code><code>  FOREACH p in P
</code><code>    k = GenerateKey(q,p)
</code><code>    QPK = AddKey(QPK, q, p, k)
</code><code>RETURN QPK
</code></pre>
<figcaption>
            <p><span class="label">Listing 1:</span> Algorithm for generating keys for quads based on existing access policies, with <code>MapInitialize</code> for initializing a map between quads and keys, <code>GenerateKey</code> which generates a key for a quad based on a policy, and <code>AddKey</code> which adds a key to a map.</p>
          </figcaption>
</figure>

        <p><em class="sidenote">one-to-one mapping between a policy and access keys? wouldn’t this imply that for each quad there’s a unique key <strong>and</strong> a unique policy? what if I have more than one policy governing access to a specific triple? this would lead to QPK(q) returning a list of (k,p) tuple?</em></p>

        <p class="sidebar-comment">There is a one to one mapping between access policies that are used for policy enforcement at query time, and access keys that are used to create privacy-preserving summaries that are needed to optimize federated querying.</p>

        <h3 id="framework-summary-creation">Summary Creation Algorithm</h3>

        <p>In practise, multiple aggregators can exist,
which are not necessarily trusted,
and each one should not necessarily aggregate over <em>all</em> sources.
For example, an aggregator could be setup within a family to aggregate over all family events that may be hosted by several people,
or a company-wide aggregator can be setup to keep track of the birthdays of all employees.</p>

        <p class="comment" data-author="RT">The paragraph above doesn’t really fit here IMO.
If I remember correctly, this used to be in the solution section.
Can we move it there?</p>

        <p>In the proposed framework, data pods expose a separate summary for each file,
and aggregators create combined summaries using these separate summaries;
and maintain a list of all source URIs that they aggregate over.
We assume that pods expose summaries that are created according to the algorithm presented in <a href="#summarization-algorithm">Listing 2</a>.
In this algorithm, a file summary is created for each quad component,
where we iterate over all the file’s quads,
and the access key that are applicable for each quad.
For each of these combinations, we add the quad component to the summary,
for the given key and file source URI.
The <code>SummaryInitialize</code> and <code>SummaryAdd</code> functions that are used in the algorithm depend on the type of summary that is being used.
A high-level example of this summarization algorithm can be seen in <a href="#figure-summary-components-privacy">Fig. 5</a>.</p>

        <p><em class="sidenote">What’s the signature of QPK? in an earlier version of the algorithm it was <code>QPK&lt;q,item&lt;p,k&gt;&gt; = MapInitialize()</code>, which wouldn’t work for something like <code>FOREACH k in QPK(q)</code> right? If <code>QPK: Q -&gt; P × K</code>, i.e. each quad maps to a tuple consisting of a policy p and key k, <strong>then <code>QPK(q)</code> would actually return only one element -&gt; the tuple <code>(p,k)</code></strong>.. right?</em></p>

        <figure id="summarization-algorithm" class="listing sidebar-comment">
<pre><code>FUNCTION CreatePrivacyPreservingSummary(Q, u, QPK)
</code><code>  INPUT:
</code><code>    set of quads Q
</code><code>    URI u of the file
</code><code>    QPK a hashmap relating quads to policies and keys
</code><code>  OUTPUT:
</code><code>    a summary Σ comprising four parts, one for each quad component: Σ.subject, Σ.predicate, Σ.object, Σ.graph
</code><code>FOREACH c in [subject, predicate, object, graph]
</code><code>  Σ.c = SummaryInitialize()
</code><code>FOREACH q in Q
</code><code>  k = QPK(q).k          # moved up as key depends on q only
</code><code>  FOREACH c in [subject, predicate, object, graph]
</code><code>    Σ.c = SummaryAdd(Σ.c, q.c, k, u)
</code><code>RETURN Σ
</code></pre>
<figcaption>
            <p><span class="label">Listing 2:</span> Algorithm for creating a summary over a file within a data pod,
with <code>SummaryAdd</code> a summary-type-dependent function for adding a quad component, key, and file URI to summary,
and <code>SummaryInitialize</code> a summary-type-dependent function for initializing a new summary.</p>
          </figcaption>
</figure>

        <figure id="figure-summary-components-privacy">
<img src="img/summary-components-privacy.svg" alt="[Privacy-preserving summarization of a file]" class="figure-width-twothird">
<figcaption>
            <p><span class="label">Fig. 5:</span> Privacy-preserving summarization of all RDF quads (<code>Q</code>) within a file (<code>u</code>),
based on a set of quad-dependent keys that are derived using a mapping function <code>QPK</code>.
<em>Note: The summary values are not necessarily an exact representation of the way the summary is stored,
these values are merely an indication of what information is used to construct the summary.</em></p>
          </figcaption>
</figure>

        <h3 id="framework-summary-aggregation">Summary Combination Algorithm</h3>

        <p>Based on the resulting file summaries,
the aggregator can create a combined summary using the algorithm from <a href="#aggregation-algorithm">Listing 3</a>.
As before, the <code>SummaryInitialize</code> and <code>SummaryCombine</code> functions that are used in these algorithms
depend on the type of summary that is being used.
<a href="#figure-summary-components-privacy-aggregated">Fig. 6</a> shows a high-level example of how this aggregation can happen in practise.</p>

        <figure id="aggregation-algorithm" class="listing">
<pre><code>FUNCTION CreateAggregatedSummary(U)
</code><code>  INPUT:
</code><code>    set of sources U
</code><code>  OUTPUT:
</code><code>    combined summary Σ comprising four parts, one for each quad component: Σ.subject, Σ.predicate, Σ.object, Σ.graph
</code><code>FOREACH c in [subject, predicate, object, graph]
</code><code>  Σ.c = SummaryInitialize()
</code><code>FOREACH u in U
</code><code>  Σ&#39; = get summaries from u
</code><code>  FOREACH c in [subject, predicate, object, graph]
</code><code>    Σ.c = SummaryCombine(Σ.c, Σ&#39;.c)
</code><code>RETURN Σ
</code></pre>
<figcaption>
            <p><span class="label">Listing 3:</span> Algorithm for creating a combined summary over a set of sources,
with <code>SummaryCombine</code> a summary-type-dependent function for combining two summaries,
and <code>SummaryInitialize</code> a summary-type-dependent function for initializing a new summary.</p>
          </figcaption>
</figure>

        <figure id="figure-summary-components-privacy-aggregated">
<img src="img/summary-components-privacy-aggregated.svg" alt="[Privacy-preserving aggregated summarization]">
<figcaption>
            <p><span class="label">Fig. 6:</span> Privacy-preserving aggregation of multiple summaries.
<em>Note: The summary values are not necessarily an exact representation of the way the summary is stored,
these values are merely an indication of what information is used to construct the summary.</em></p>
          </figcaption>
</figure>

        <p>In practise, summaries and combined summaries require some bookkeeping.
Each file summary must remain up-to-date with respect to the file’s contents.
This could be done by either immediately invalidating the summary upon file changes,
or by periodically regenerating the summary.
The combined summary requires similar actions to avoid going stale.
This can be achieved through immediate notifications from the pod to the aggregator upon file changes,
or the aggregator can periodically scan the files or its summaries for changes.</p>

        <h3 id="framework-client">Client-side Querying Algorithm</h3>

        <p>Since file-based APIs are the basis for data retrieval on the Web as prescribed by the HTTP protocol,
we assume this as a starting point for federated querying in decentralized environments.
Furthermore, we consider quad pattern-based access to file sources instead of more complex <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/">SPARQL queries</a> <span class="references">[<a href="#ref-11">11</a>]</span>.
This is because triple and quad patterns are the fundamental elements of SPARQL queries,
and any SPARQL query can be decomposed into multiple smaller quad pattern queries.
For example, client-side query engines such as <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Resource/">Comunica</a> <span class="references">[<a href="#ref-32">32</a>]</span> decompose any SPARQL query
into a sequence of quad pattern queries for evaluation against heterogeneous sources,
where the results of these quad pattern queries are joined together locally.
More complex SPARQL features such as <code>FILTER</code> and aggregates are fully handled client-side.
Although intelligent clients could detect more expressive interfaces such as
<a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/">SPARQL endpoints</a> <span class="references">[<a href="#ref-9">9</a>]</span> and <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2016.03.003"><a href="http://linkeddatafragments.org/publications/jws2016.pdf">Triple Pattern Fragments</a></span> <span class="references">[<a href="#ref-33">33</a>]</span> interfaces,
and make use of them during query execution, we consider this out-of-scope for this work.</p>

        <p>Assuming we have an aggregator exposing a summary over a set of sources,
we introduce the algorithm in <a href="#client-algorithm">Listing 5</a> where a client-side query engine can make use of an aggregator’s summary
to reduce the number of sources the client should query over, i.e., to <em>source selection</em>.
As input, this algorithm assumes a quad pattern query,
the list of access keys provided by the user,
and the summary and list of sources it obtained from an aggregator.
Based on these inputs, the client will iterate over all non-variable quad components
and all available keys.
For each combination, it will first do a pre-filtering step before locally iterating over all sources.
It will check whether or not the component value
is present in the summary for the current key and component,
with source URI set to <code>ε</code> to match with all sources.
If it is not present, then we return an empty array, as none of the sources will contain the given component value.
If it is present, some of the sources <em>may</em> contain the component value,
because we consider summaries as being probabilistic.
After that, we iterate over each source URI, and check its presence in the summary of the current component,
combined with the component value and key.
When a true negative is found for a source, this source is removed from the list of sources.
Finally, the remaining list of sources is returned,
which can be used by the query engine to execute the quad pattern query over.
In this algorithm, the <code>SummaryContains</code> also depends on the type of summary that is being used.
<a href="#figure-query-execution">Fig. 7</a> shows an example of how this source selection algorithm can be used in client-side query engines.</p>

        <p><em class="sidenote">in <a href="#figure-query-execution">Fig. 7</a> we use <code>q</code> to denote a single quad and <code>Q</code> for a query.. is <code>q</code> now a single quad or a quad pattern query?</em></p>

        <figure id="client-algorithm" class="listing sidebar-comment">
<pre><code>FUNCTION SelectSources(q, K, Σ, U)
</code><code>  INPUT:
</code><code>    quad pattern query q
</code><code>    access keys K
</code><code>    summary Σ comprising four parts, one for each quad component: Σ.subject, Σ.predicate, Σ.object, Σ.graph
</code><code>    set of sources U
</code><code>  OUTPUT:
</code><code>    list of selected sources U&#39;
</code><code>U&#39; = []
</code><code>FOREACH c in [subject, predicate, object, graph]
</code><code>  IF q.c not variable
</code><code>    FOREACH k in K
</code><code>      IF ! SummaryContains(Σ.c, q.c, k, ε)
</code><code>        RETURN []
</code><code>      FOREACH u in U
</code><code>        IF ! SummaryContains(Σ.c, q.c, k, u)
</code><code>          add u to U&#39;
</code><code>RETURN U&#39;
</code></pre>
<figcaption>
            <p><span class="label">Listing 5:</span> Client-side algorithm for selecting query-relevant sources for a quad pattern query
based on a given privacy-preserving summary.
<code>SummaryContains</code> is a summary-type-dependent function for checking if a summary contains a given quad component
for a given key and source URI.</p>
          </figcaption>
</figure>

        <figure id="figure-query-execution">
<img src="img/query-execution.svg" alt="[Query execution over privacy-preserving summaries]">
<figcaption>
            <p><span class="label">Fig. 7:</span> Federated query execution using a privacy-preserving summary.
<em>Note: The summary values are not necessarily an exact representation of the way the summary is stored,
these values are merely an indication of what information is used to construct the summary.</em></p>
          </figcaption>
</figure>

        <p>The presented algorithm should be seen as a basis for federated querying over decentralized environments with private data,
where there is a single aggregator, and all sources we want to query over are considered by the aggregator.
In practise, multiple aggregators can exist,
they may apply to overlapping sources,
and some sources may not be aggregated at all.
For these cases, extensions to this algorithm will be needed,
which we consider out-of-scope for this work.</p>

        <h3 id="framework-access-control">Access Control</h3>

        <p>Once the client has obtained the list of sources that it needs to query, the next step is to execute the query against each source.
Here there is a need for access control enforcement, such that it is possible to check that a client does in fact possess the credentials necessary to execute the request.</p>

        <figure id="client-algorithm" class="listing">
<pre><code>FUNCTION QuerySources(i, q, U)
</code><code>  INPUT:
</code><code>    client identification i
</code><code>    quad pattern query q
</code><code>    list of sources U
</code><code>  OUTPUT:
</code><code>    query results R
</code><code>R = {}
</code><code>FOREACH u in U
</code><code>  R = R ∪ ExecuteQuery(i, q, u)
</code><code>RETURN R
</code></pre>
<figcaption>
            <p><span class="label">Listing 5:</span> Client-side algorithm for querying query-relevant sources.
<code>ExecuteQuery</code> is a function that executes a query (i.e. request) against a particular source. For access control purposes, a client identification (e.g., WebID) has to be provided by the client together with the respective query.</p>
          </figcaption>
</figure>

        <p class="comment" data-author="RT">It is not clear to me if this section is talking about the client-side part (clients sends auth query to the server), or the server-side part (server checks client auth, and only emits quads that are authorized for this auth).
We might even want to create two separate dedicated sections for this.</p>

        <h4 id="server-side-access-control-authorization">Server-side Access Control (Authorization)</h4>

        <p>In the proposed algorithm a map relating quads to policies and keys is used to identify access policies that govern a particular query. We assume that there may be multiple policies that govern a particular quad and thus envisage a simple conflict resolution strategy whereby either prohibitions override permissions or visa versa. The algorithm stops as soon as it finds a policy that permits the given query to be executed and returns the results of the query execution.</p>

        <figure id="figure-request-processing" class="figure">
<img src="img/request-processing.svg" alt="[Shape-based access control]" style="width: 40%; display: block; margin: auto;" class="figure-width-half">
<figcaption>
            <p><span class="label">Fig. 11:</span> A server validates requests <code>r ∈ R</code> with <code>r = ⟨i, a, q⟩</code> consisting of the requester’s client identification <code>i</code>, the requested access mode <code>a</code>, and a quad pattern query <code>q</code>, against a set of <em>applicable</em> access control policies <code>P'⊆ P</code>.
A policy <code>p ∈ P'</code> with <code>p = ⟨s, a, o⟩</code> is <em>applicable</em> to a request <code>r ∈ R</code> if the request conforms to the shape; policy <code>p</code> was specified against.</p>
          </figcaption>
</figure>

        <figure id="access-control-algorithm" class="listing">
<pre><code>FUNCTION ProcessRequest(i, q, QPK)
</code><code>  INPUT:
</code><code>    client identification i
</code><code>    quad pattern query q
</code><code>    QPK a hashmap relating quads to policies and keys
</code><code>  OUTPUT:
</code><code>    query results R
</code><code>R = {}
</code><code>// TODO add abstractions
</code><code>IF i not verified
</code><code>  RETURN {}
</code><code>FOREACH p in GetPolicies(QPK, i, q)
</code><code>  IF p.type = prohibition &amp; cr = prohibition_overrides
</code><code>    break
</code><code>  ELSE
</code><code>    R = ExecuteQueryWithAccessControl(i, q, p)
</code><code>    break
</code><code>RETURN R
</code></pre>
<figcaption>
            <p><span class="label">Listing 6:</span> An algorithm that takes the requesters credentials, the requested access right, a quad pattern, and a policy, and returns the query execution results. The algorithm is composed of an <code>AllowedAccess</code> function that checks if access is permitted, and an <code>ExecuteQueryWithAccessControl</code> function that executes a query and adds the result to the result list.</p>
          </figcaption>
</figure>

      </div>
</section>

  <section id="solution" inlist="" rel="schema:hasPart" resource="#solution">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">A Possible Instantiation</h2>

        <p>In this section, we present an instantiation of the proposed framework and identify challenges that need to be addressed, placing a particular focus on techniques for access policy specification, summarization generation and maintenance, and access control enforcement.</p>

        <p class="todo">ALL: We should revisit our use case scenario here</p>

        <h3 id="access-policy-specification">Access Policy Specification</h3>

        <p>We assume that pod owners need to be able to specify access control policies that can be enforced both from an indexing and also a query processing perspective, taking into consideration the following core requirement:</p>

        <ul>
          <li>
<strong>No data leaking</strong>: Access restricted data must not be available to those who are not authorised to access it.</li>
        </ul>

        <p><em class="sidenote">in <a href="#figure-use-case">Fig. 1</a> we say <strong>“All triples in each profile are annotated with a role for users that can read that triple.”</strong> -&gt; would we still need 3 separate files for differentiating between access rights in that case?</em></p>

        <p class="sidebar-comment">From a policy specification perspective, our pod owners (Alice, Bob, and Carol) could create three separate files that are used to distinguish between data that is accessible by: <em>everyone</em>, <em>acquaintances</em>, and <em>friends</em>. In such a scenario, authorisations could abstractly be represented as lists of <em>roles</em>, <em>access rights</em>, and <em>pods</em>, such that:</p>

        <ul>
          <li>
            <p>Authorisation Rule <em>R1<sub>C</sub></em>, a <em>permission</em> which states that everyone has read access to the name property, is represented as <code>&lt;everyone, read access, everyone file&gt;</code>, where name is stored in the everyone file.</p>
          </li>
          <li>
            <p>Authorisation Rule <em>R2<sub>C</sub></em>, which states that acquaintances have read access to the e-mail property, is represented as <code>&lt;acquaintances, read access, acquaintances file&gt;</code>, where e-mail is stored in the acquaintances file.</p>
          </li>
          <li>
            <p>Authorisation Rule <em>R3<sub>C</sub></em>, which states that friends have read access to the telephone number property, is represented as <code>&lt;friends, read access, friends file&gt;</code>, where the telephone number is stored in the friends file.</p>
          </li>
        </ul>

        <p>More formally, we consider</p>

        <figure id="def-authorisation" class="definition">
          <figcaption>
            <p><span class="label">Fig. 9:</span> Authorisation</p>
          </figcaption>
          <p>An <strong>Authorisation</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">r \in R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> is represented as a tuple <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mo stretchy="false">⟨</mo><mi>s</mi><mo separator="true">,</mo><mi>a</mi><mo separator="true">,</mo><mi>o</mi><mo stretchy="false">⟩</mo></mrow><annotation encoding="application/x-tex">r = \langle s, a, o\rangle</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⟨</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">o</span><span class="mclose">⟩</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> represents the subjects to whom the rule applies to, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> denotes the granted access right, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi></mrow><annotation encoding="application/x-tex">o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">o</span></span></span></span> specifies the resources subjects <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> can exercise access right <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> over.</p>
        </figure>

        <figure id="def-policy" class="definition">
          <figcaption>
            <p><span class="label">Fig. 10:</span> Access Policy</p>
          </figcaption>
          <p>An <strong>Access Policy</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> is represented as a set of authorisations <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>⊆</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">P \subseteq R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span></p>
        </figure>

        <div class="bs-callout bs-callout-info">
          <p><strong>Representation </strong></p>

          <p>Should we follow a similar representation as in <a href="#use-case">Section 3</a>? e.g.:</p>

          <p>Rule <em>R1<sub>C</sub></em>, a <em>permission</em> which states that everyone has read access to the name property where name is stored in the everyone file, is represented as:</p>

          <ul>
            <li>
<code>r1 = ⟨{s | s ∈ Everyone}, read, {name}⟩</code><br>
or maybe even</li>
            <li>
<code>r1 = ⟨{s | s ∈ Everyone}, read, {o | o ∈ File</code><sub><code>Everyone</code></sub><code>∧ o ⊆ name}⟩</code>
</li>
          </ul>

          <p>otherwise - unless the friends file already contains only those triples that can be read by <strong>all</strong> friends - a rule like:</p>

          <p style="padding-left:1em;">
<em>friends have read access to the telephone number property, is represented as <code>&lt;friends, read access, friends file&gt;</code>, where the telephone number is stored in the friends file.</em>
</p>

          <p>would provide access to more information than intended (only read access to telephone number property should be provided, not read access to the entire friends file)</p>

        </div>

        <!-- - Rule _R1<sub>C</sub>_, a _permission_ which states that everyone has read access to the name property, is represented as `<everyone, read access, everyone file>`, where name is stored in the everyone file.


- Rule _R2<sub>C</sub>_, which states that acquaintances have read access to the e-mail property, is represented as `<acquaintances, read access, acquaintances file>`, where e-mail is stored in the acquaintances file.

- Rule _R3<sub>C</sub>_, which states that friends have read access to the telephone number property, is represented as `<friends, read access, friends file>`, where the telephone number is stored in the friends file. -->

        <p>In order to support privacy-preserving summaries, there is a need to generate access keys for both the acquaintances and the friends files, such that the summary generation process does not work with plain text attributes but rather cipher text. Given that data in the everyone file is public by default, no key is needed.</p>

        <p>In this paper we propose that there is a one-to-one mapping between protected (i.e. non public files) and access keys that are used to create data summaries. Our initial proposal makes use of simple symmetric keys, however for more complex scenarios both attribute-based encryption and/or key derivation algorithms could be use to provide support for more complex access policies.</p>

        <p>When to comes to policy management, there is a need to ensure that (i) access keys are tightly bound to access policies, and (ii) said keys are distributed to authorised individuals (i.e. acquaintances and friends). In order to revoke access to a particular individual one would need to regenerate the keys and redistribute them to authorised individuals.</p>

        <h3 id="summary-generation-and-maintenance">Summary Generation and Maintenance</h3>

        <p>The technical requirements for enabling federated querying in an efficient manner through privacy-preserving aggregators are mainly driven by the summarization technology. In this context symmetric keys are used to create privacy-preserving summaries that do not leak access restricted data. In the following, we discuss the role played by Bloom filters when it comes to constructing privacy-preserving data summaries. Subsequently, we highlight challenges related to parameter handling and source-aggregator communication.</p>

        <h4 id="constructing-privacy-preserving-data-summaries">Constructing Privacy-Preserving Data Summaries</h4>

        <p>We consider Approximate Membership Functions (AMFs), such as Bloom filters, being
one possible candidate for such summaries that meet the following requirements:</p>

        <ul>
          <li>
<strong>No data leaking</strong>:
Values in Bloom filters are hashed, which can not be reversed.</li>
          <li>
<strong>Value additions</strong>:
Additions to Bloom filters are possible by inserting a bit string.
<code>SummaryInitialize() = 0</code> and
<code>SummaryAdd(Σ.c, q.c, k, u) = Σ.c | (q.c &amp; k) | u</code>
</li>
          <li>
<strong>Summary combinations</strong>
Bloom filters can be combined by <code>OR</code>-ing them.
<code>SummaryCombine(Σ.c, Σ'.c) = Σ.c | Σ'.c</code>.</li>
          <li>
<strong>Authorized membership checking</strong>
Membership in Bloom filters can be tested by hashing the value,
and checking its membership inside the filter.
<code>SummaryContains(Σ.c, q.c, k, u) = Σ.c[(q.c &amp; k) | u]</code>.</li>
        </ul>

        <p>The main advantage of using AMFs such as Bloom filters is that all of the performance-critical operations on summaries (adding, combining, membership checking) can happen very efficiently, as these are essentially just bitwise operations.</p>

        <h4 id="parameter-handling">Parameter Handling</h4>

        <p>When using AMFs, it is important to take account that these have certain parameters,
and that all operations must be known before any operation can be done with them.
For example, for Bloom filters the parameters are the number of hashes and bits.
These parameters and the number of entries all impact the false positive error rate.
Concretely, these parameters have to be identical before AMFs can be combined within an aggregator,
and they have to be known before a client can make use of them.</p>

        <p>In a decentralized environment, it is however difficult to reach a consensus between all parties to use fixed parameters.
Furthermore, since the number of values within an AMF has an impact on the error rate,
it is sometimes even required to use different parameters for different numbers of entries.
As such, no single set of AMF parameters should be used.
This does however mean that a parameter determination mechanism is needed for aggregators
that want to combine multiple AMFs.
This mechanism is driven by the file sizes within each data pod,
and by the number of sources the aggregator works over.
Once the aggregator has determined these numbers,
it can determine an appropriate set of AMF parameters,
which must then be sent to each data pod to trigger an AMF creation for the requested file under the given set of parameters.
In cases where many aggregators request such AMFs,
the data pods may decide to only support a fixed set of parameters to reduce the load on them, and to enable caching of AMFs.
For this, some kind of parameter negotiation may be required between the aggregator and all data pods.</p>

        <h4 id="maintenance-of-summaries-within-sources">Maintenance of Summaries within Sources</h4>

        <p>Since the creation of an AMF for a file can become expensive,
sources need be intelligent on when these AMFs are created.
Within this work, we discuss four approaches:</p>

        <ol>
          <li>
<strong>Eager AMF creation</strong>:
<br>
For each file, an AMF is created as soon as a change occurs in the file.
This ensures that the AMFs are always synchronized with the state of the files,
and requests for AMFs will always return instantly.
The downside of this approach is that frequently changing files may cause more AMF updates than needed,
even when certain AMFs may not be used that often.</li>
          <li>
<strong>Transient AMF creation</strong>:
<br>
When the AMF of a file is requested, it is created on-the-fly.
This means that the server does not store any AMFs physically,
but only constructs them when needed.
The advantages of this is that AMFs are always synchronized with the state of the files.
The main disadvantage is that requests for AMFs are slowed down by AMF creation time,
which may be significant for larger files.</li>
          <li>
<strong>Lazy AMF creation</strong>:
<br>
This approach combines the two previous approaches.
Each AMF will only be created and stored from the moment that it is requested.
From the moment that a file change is detected, the stored AMF is invalidated,
which will cause a recalculation when it will be requested again.
The advantages of this approach are that AMFs are always synchronized with the state of the files,
and that even when files change frequently, no unneeded AMF creations will occur.
The downside is that requests for AMFs are sometimes slowed down by AMF creation time.</li>
          <li>
<strong>Periodic AMF creation</strong>:
<br>
This approach involves creating AMFs for files at a following a certain frequency,
for example each hour, or each day.
The advantage of this approach is that requests for AMFs will always return instantly.
The downsides are that AMFs may not always be synchronized with the state of the files,
and that more AMF updates occur than needed.</li>
        </ol>

        <p>In practise, we expect that different approaches may be valuable for different types of use cases.
For example, for sources that contain static or slowly changing files,
the eager and periodic approaches may be beneficial.
But for sources that contain very volatile files,
the transient and lazy approaches may work better.</p>

        <p>Furthermore, some of these approaches may be combined with each other.
For example, the lazy approach could be combined with the periodic approach
so that for small files the regular lazy approach is followed,
but for larger files, AMFs are periodically created to avoid slowing down requests for these AMFs.</p>

        <p>One open challenge for volatile files is to investigate incremental AMF creation approaches
where only small parts of the data is added or removed.
For instance, Bloom filters allow data to be appended, but not removed.</p>

        <h4 id="source-aggregator-communication">Source-Aggregator Communication</h4>

        <p>Different <em>push</em> and <em>pull</em> based techniques can be used to trigger aggregated summary creation.
Push based techniques require the aggregators to <em>subscribe</em> to the sources, after which the sources could <em>notify</em> the aggregators upon any change, after which the aggregators could restart aggregated summary creation.
Pull based techniques require the aggregator to periodically poll the applicable sources,
which could be done efficiently by sending <code>HEAD</code> requests and checking the last modification date of the files or summaries in the response headers.
Once the aggregator detects a change in one of the sources, the aggregated summary creation could restart.
<a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/ldn/">Linked Data Notifications</a> <span class="references">[<a href="#ref-6">6</a>]</span> is one possible technique for sending such notifications. In practise, there is a need to support both push and pull based techniques, for instance when only some sources support change subscriptions, which means that other sources will require polling.</p>

        <h3 id="source-selection">Source Selection</h3>

        <p>As discussed in <a href="#framework-client">Subsection 4.6</a>, a client-side query engine can make use of the aggregator’s summary to perform source selection,
in order to reduce the number of sources that are being consulted by this engine.</p>

        <p>As the discussed summaries allow source selection based on quad patterns instead of full SPARQL queries,
source selection can be pushed down into the query plan,
which allows quad patterns in the query to be executed over a different range of sources.
Furthermore, instead of applying source selection before query execution,
this allows source selection to optionally happen adaptively during query execution,
following the federation algorithm of <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2016.03.003"><a href="http://linkeddatafragments.org/publications/jws2016.pdf">Triple Pattern Fragments</a></span> <span class="references">[<a href="#ref-33">33</a>]</span>.
A hybrid approach where source selection happens both before and during query execution could be investigated.</p>

        <p>One open challenge will be to investigate how this file-based source selection method could be combined and enhanced
by existing source selection methods for SPARQL endpoints, such as Hibiscus <span class="references">[<a href="#ref-34">34</a>]</span> and Splendid <span class="references">[<a href="#ref-35">35</a>]</span>.</p>

        <p>Another open challenge is to determine the applicable aggregators within a client.
For now, we assume that clients will have zero or more preconfigured links to certain aggregators,
such as an aggregator for a person’s family, or an employee’s company.
In future work, more elaborate aggregator discovery mechanisms should be investigated,
where for example an aggregator is discovered based on the topic of a certain query,
or based on the current location of the user.</p>

        <h3 id="query-execution">Query Execution</h3>

        <p>Once the query engine has identified the data sources that could potentially contribute results to their query, the query engine needs to authenticate to the server(s) and execute the query or parts thereof. In turn the server is responsible for authenticating the request, enforcing access control, and executing the query or parts thereof. Concretely, we address the following core requirements:</p>

        <ul>
          <li>
<strong>Authentication</strong> It must be possible for the data source to verify the integrity of the requesting party.</li>
          <li>
<strong>Access control enforcement</strong> It must be possible for the data source to limit query results based on a set of access policies.</li>
        </ul>

        <h4 id="authentication-1">Authentication</h4>

        <p>Web Identity and Discovery, is a mechanism used to uniquely identify and authenticate a person, company, organisation or other entity, by means of a URI. Essentially a WebID is a HTTP URI that should: (i) be under the control of the entity it describes; (ii) be linkable on the web; (iii) describe the entity is represents; (iv) enable authentication and access control; (v) respect the privacy of the entity it describes; (v) rely solely on HTTP and semantic Web technologies. A description of the agent is provided in an RDF document, known as a WebID profile, which can be dereferenced using 303 or Hash URIs. The WebID-TLS protocol (where TLS stands for Transport Layer Security) specifies how together the WebID profile and public key certificates, can be used to authenticate users. The user places their WebID profile document URI in the <em>Subject Alternative Names</em> field of their certificate. Once the certificate has been generated the user adds the public key details to their WebID profile document. A service wishing to authenticate the user, needs to verify that the public key of the certificate it receives matches the public key specified in the WebID profile.</p>

        <h4 id="access-control-enforcement">Access Control Enforcement</h4>

        <p>For enforcement purposes, we envision a mechanism that translates access policies (i.e. sets of authorisations) into constraints (e.g., Data shapes like <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/shacl/">SHACL</a> <span class="references">[<a href="#ref-36">36</a>]</span>) against which requests and respective query results are then validated against.</p>

        <!-- <figure id="figure-request-processing">
<img src="img/request-processing.svg" alt="[Shape-based access control]" style="width: 40%; display: block; margin: auto;"  class="figure-width-half">
<figcaption markdown="block">
A server matches requests consisting of a client identification `i`, the requested access mode `a`, and a quad pattern query `q`, against a set of access control policies `P`.
A policy `p ∈ P` is applicable for a request `(i, a, q)` if the request conforms to the shape; policy `p` was specified against.
</figcaption>
</figure>

SIMON: Change this figure and the example so that it aligns with the use case scenario
{:.todo} -->

        <!--
This allows for expressing more fine-grained access control policies, such as:
* As outlined in <span class="references">\[<a href="#ref-37">37</a>\]</span>, shapes languages such as <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/TR/shacl/">SHACL</a> <span class="references">\[<a href="#ref-36">36</a>\]</span>, specifically address the need to constrain the data in a graph to a certain shape
* shapes (SHACL/ShEx) and <a property="schema:citation http://purl.org/spar/cito/cites" href="https://linkeddatafragments.github.io/Article-Declarative-Hypermedia-Responses/">using shapes for Web APIs</a> <span class="references">\[<a href="#ref-38">38</a>\]</span>
* (shacl-spec): validation-based (~filter) and (shacl note): filter/rule-based (related https://github.com/solid/data-interoperability-panel/issues/34)
{:.todo}
-->

        <!--
* Data owners are responsible for enforcing access control (as opposed to other approaches where federation engine takes care of that). We assume that access control is already taken care of at the (client-side) federation engine.
* Build on Solid's WebID-OIDC for auth, and WAC for access control.
* Allow shape-based/quadpattern-based (SHACL/SHEX) access modes in .acl files. (advantage of shapes is that fewer keys may be needed, which reduces the complexity of key mgmt) (motivation for keys is that Solid is going to use it for data validation: https://github.com/solid/data-interoperability-panel/blob/b2591bf2f8808972e5459db2aa4ac8d9854f5b5e/data-validation/use-cases.md)
* Right now, we do it role-based, but it could be attribute-based as well.
{:.todo} -->

      </div>
</section>

  <!-- <section >
<div datatype="rdf:HTML" property="schema:description" markdown="block">
## Evaluation
{:#evaluation}

Attacker model.
See example at https://drive.google.com/file/d/1Jsr6AHWsqetax3RF8_CjYnHO9s2uO8Sy/view
{:.todo}

</div>
</section>
 -->
  <!-- <section >
<div datatype="rdf:HTML" property="schema:description" markdown="block">
## Related Work
{:#related-work}

Solid currently uses <a property="schema:citation http://purl.org/spar/cito/cites" href="https://github.com/solid/web-access-control-spec">Web Access Control (WAC)</a> <span class="references">\[<a href="#ref-8">8</a>\]</span>,
which provides access control over _documents_.
For some use cases, where documents are large, and access is only granted to specific parts of the document,
WAC does not offer a sufficient granularity.
For this, vocabulary extensions of WAC were introduced <span class="references">\[<a href="#ref-39">39</a>,&thinsp;<a href="#ref-40">40</a>\]</span>,
where more fine-grained access can be granted to specific RDF resources or named graphs,
but are not being used in practise. 

 {:.todo}
Emphasize that Solid *only* does WAC, not the extensions. So only access to full documents.
Also say that even the extensions are not fine-grained enough. 

For this work, we assume a decentralized environment as provided by Solid and its used standards
to illustrate our use case.
Furthermore, we will introduce extensions of the used standards to improve query execution
over multiple Solid data pods in a privacy-preserving manner. 




</div>
</section>
-->
  <section id="conclusions" inlist="" rel="schema:hasPart" resource="#conclusions">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Conclusions</h2>

        <p>In this article, we introduced our vision of a high-level framework
to optimize federated querying within decentralized environments
over data with any kind of access control.
For this, we introduce the use of theoretical privacy-preserving summaries.
This framework serves as a basis for future work into the areas of decentralization, querying and access control.</p>

        <p>To offer suggestions for future research, we discuss several possible instantiations of this framework,
where we for instance discuss Bloom filters as a technique for privacy-preserving summaries.
In future work, we will investigate these Bloom filters in more depth,
and evaluate their implementation into decentralized environments in terms of performance and security.
Additionally, we will further investigate how identity management can be managed effectively and efficiently within decentralized environments.
Finally, we will implement and evaluate the performance of shape-based access control.</p>

        <p>If we want to move more towards a truly decentralized Web,
but still want maintain our current applications that are primarily centralized,
we will need novel techniques for achieving the same levels of user-perceived performance.
Our work provides a basis for this,
where we focus on improving performance when querying over large amounts of personal decentralized data.
However, this work is merely a starting point for the creation of more concrete techniques
for optimizing querying over personal data within decentralized environments.</p>

      </div>
</section>

</main>

<footer><section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="#solid" typeof="schema:Article">Mansour, E., Sambra, A.V., Hawke, S., Zereba, M., Capadisli, S., Ghanem, A., Aboulnaga, A., Berners-Lee, T.: A demonstration of the solid platform for social web applications. In: Proceedings of the 25th International Conference Companion on World Wide Web. pp. 223–226. International World Wide Web Conferences Steering Committee (2016).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="#summaries" typeof="schema:Article">Umbrich, J., Hose, K., Karnstedt, M., Harth, A., Polleres, A.: Comparing data summaries for processing live queries over linked data. World Wide Web. 14, 495–544 (2011).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/" typeof="schema:CreativeWork">Cyganiak, R., Wood, D., Lanthaler, M.: RDF 1.1: Concepts and Abstract Syntax. W3C, <a href="https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/">https:/​/​www.w3.org/TR/2014/REC-rdf11-concepts-20140225/</a> (2014).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="https://www.w3.org/DesignIssues/LinkedData.html" typeof="schema:CreativeWork">Berners-Lee, T.: Linked Data. <a href="https://www.w3.org/DesignIssues/LinkedData.html">https:/​/​www.w3.org/DesignIssues/LinkedData.html</a> (2009).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="https://www.w3.org/TR/ldp/" typeof="schema:CreativeWork">Speicher, J.A., Steve, Malhotra, A.: Linked Data Platform 1.0. W3C, <a href="https://www.w3.org/TR/ldp/">https:/​/​www.w3.org/TR/ldp/</a> (2015).</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="https://www.w3.org/TR/ldn/" typeof="schema:CreativeWork">Capadisli, S., Guy, A.: Linked Data Notifications. W3C, <a href="https://www.w3.org/TR/ldn/">https:/​/​www.w3.org/TR/ldn/</a> (2017).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="https://www.w3.org/2005/Incubator/webid/spec/identity/" typeof="schema:CreativeWork">Sporny, M., Inkster, T., Story, H., Harbulot, B., Bachmann-Gmür, R.: WebID 1.0 Web Identity and Discovery. W3C, <a href="https://www.w3.org/2005/Incubator/webid/spec/identity/">https:/​/​www.w3.org/2005/Incubator/webid/spec/identity/</a> (2014).</dd>
  <dt id="ref-8">[8]</dt>
  <dd resource="https://github.com/solid/web-access-control-spec" typeof="schema:CreativeWork">Web Access Control (WAC). <a href="https://github.com/solid/web-access-control-spec">https:/​/​github.com/solid/web-access-control-spec</a> (2019).</dd>
  <dt id="ref-9">[9]</dt>
  <dd resource="https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/" typeof="schema:CreativeWork">Feigenbaum, L., Todd Williams, G., Grant Clark, K., Torres, E.: SPARQL 1.1 Protocol. W3C, <a href="https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/">https:/​/​www.w3.org/TR/2013/REC-sparql11-protocol-20130321/</a> (2013).</dd>
  <dt id="ref-10">[10]</dt>
  <dd resource="#sparqlfederation" typeof="schema:Article">Saleem, M., Khan, Y., Hasnain, A., Ermilov, I., Ngonga Ngomo, A.-C.: A fine-grained evaluation of SPARQL endpoint federation systems. Semantic Web. 7, 493–518 (2016).</dd>
  <dt id="ref-11">[11]</dt>
  <dd resource="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/" typeof="schema:CreativeWork">Harris, S., Seaborne, A., Prud’hommeaux, E.: SPARQL 1.1 Query Language. W3C, <a href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/">https:/​/​www.w3.org/TR/2013/REC-sparql11-query-20130321/</a> (2013).</dd>
  <dt id="ref-12">[12]</dt>
  <dd resource="http://ceur-ws.org/Vol-2451/paper-28.pdf" typeof="schema:Article">Vander Sande, M., de Valk, S., Meijers, E., Taelman, R., Van de Sompel, H., Verborgh, R.: Discovering Data Sources in a Distributed Network of Heritage Information. Proceedings of the Posters and Demo Track of the 15th International Conference on Semantic Systems. (2019).</dd>
  <dt id="ref-13">[13]</dt>
  <dd resource="http://crystal.uta.edu/~mcguigan/cse6350/papers/Bloom.pdf" typeof="schema:Article">Bloom, B.H.: Space/time trade-offs in hash coding with allowable errors. Communications of the ACM. 13, 422–426 (1970).</dd>
  <dt id="ref-14">[14]</dt>
  <dd resource="https://dl.acm.org/citation.cfm?doid=2063576.2063988" typeof="schema:Article">Pu, X., Wang, J., Luo, P., Wang, M.: AWETO: efficient incremental update and querying in RDF storage system. In: Proceedings of the 20th ACM international conference on Information and knowledge management (2011).</dd>
  <dt id="ref-15">[15]</dt>
  <dd resource="https://www.researchgate.net/profile/Thomas_Neumann2/publication/47863714_Scalable_Join_Processing_on_Very_Large_RDF_Graphs/links/00b7d51d1687cae740000000.pdf" typeof="schema:Article">Neumann, T., Weikum, G.: Scalable join processing on very large RDF graphs. In: Proceedings of the 2009 ACM SIGMOD International Conference on Management of data. pp. 627–640. ACM (2009).</dd>
  <dt id="ref-16">[16]</dt>
  <dd resource="http://linkeddatafragments.org/publications/iswc2015-amf.pdf" typeof="schema:Article">Vander Sande, M., Verborgh, R., Van Herwegen, J., Mannens, E., Van de Walle, R.: Opportunistic Linked Data querying through approximate membership metadata. In: International Semantic Web Conference. pp. 92–110. Springer (2015).</dd>
  <dt id="ref-17">[17]</dt>
  <dd resource="https://domino.mpi-inf.mpg.de/intranet/ag5/ag5publ.nsf/0/DAAD136B50B0C0ECC12579E6004D6582/$file/p2-hose.pdf" typeof="schema:Article">Hose, K., Schenkel, R.: Towards benefit-based RDF source selection for SPARQL queries. In: Proceedings of the 4th International Workshop on Semantic Web Information Management. p. 2. ACM (2012).</dd>
  <dt id="ref-18">[18]</dt>
  <dd resource="#Sambra2014" typeof="schema:CreativeWork">Sambra, A., Story, H., Berners-Lee, T.: Web Identity and Discovery. W3C (2014).</dd>
  <dt id="ref-19">[19]</dt>
  <dd resource="#Inkster2014" typeof="schema:CreativeWork">Inkster, T., Story, H., Harbulot, B.: WebID Authentication over TLS. W3C (2014).</dd>
  <dt id="ref-20">[20]</dt>
  <dd resource="#Hollenbach2009" typeof="schema:Article">Hollenbach, J., Presbrey, J., Berners-Lee, T.: Using rdf metadata to enable access control on the social semantic web. In: Proceedings of the Workshop on Collaborative Construction, Management and Linking of Structured Knowledge (CK2009) (2009).</dd>
  <dt id="ref-21">[21]</dt>
  <dd resource="https://openid.net/specs/openid-connect-core-1_0.html " typeof="schema:CreativeWork">Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., Mortimore, C.: OpenID Connect Core 1.0. OpenID Foundation, <a href="https://openid.net/specs/openid-connect-core-1_0.html">https:/​/​openid.net/specs/openid-connect-core-1_0.html</a> (2014).</dd>
  <dt id="ref-22">[22]</dt>
  <dd resource="#fett2017web" typeof="schema:Article">Fett, D., Küsters, R., Schmitz, G.: The web SSO standard openid connect: In-depth formal security analysis and security guidelines. In: 2017 IEEE 30th Computer Security Foundations Symposium (CSF). pp. 189–202. IEEE (2017).</dd>
  <dt id="ref-23">[23]</dt>
  <dd resource=" https://www.egiz.gv.at/files/download/Self-Sovereign-Identity-Whitepaper.pdf" typeof="schema:CreativeWork">Abraham, A.: Self-Sovereign Identity: Whitepaper about the Concept of Self-Sovereign Identity including its Potential. EGIZ, <a href="https://www.egiz.gv.at/files/download/Self-Sovereign-Identity-Whitepaper.pdf">https:/​/​www.egiz.gv.at/files/download/Self-Sovereign-Identity-Whitepaper.pdf</a> (2017).</dd>
  <dt id="ref-24">[24]</dt>
  <dd resource="#muhle2018survey" typeof="schema:Article">Mühle, A., Grüner, A., Gayvoronskaya, T., Meinel, C.: A survey on essential components of a self-sovereign identity. Computer Science Review. 30, 80–86 (2018).</dd>
  <dt id="ref-25">[25]</dt>
  <dd resource="#Villata2011" typeof="schema:Article">Villata, S., Delaforge, N., Gandon, F., Gyrard, A.: An Access Control Model for Linked Data. In: On the Move to Meaningful Internet Systems: OTM 2011 Workshops. pp. 454–463 (2011).</dd>
  <dt id="ref-26">[26]</dt>
  <dd resource="http://ceur-ws.org/Vol-781/paper6.pdf" typeof="schema:Article">Sacco, O., Passant, A.: A Privacy Preference Manager for the Social Semantic Web. In: Semantic Personalized Information Management: Retrieval and Recommendation. CEUR-WS (2011).</dd>
  <dt id="ref-27">[27]</dt>
  <dd resource="http://dx.doi.org/10.1007/978-3-642-39218-4_6" typeof="schema:Article">Kirrane, S., Mileo, A., Decker, S.: Applying DAC Principles to the RDF Graph Data Model. In: Security and Privacy Protection in Information Processing Systems. pp. 69–82. Springer Berlin Heidelberg (2013).</dd>
  <dt id="ref-28">[28]</dt>
  <dd resource="#kasten2013towards" typeof="schema:Article">Kasten, A., Scherp, A., Armknecht, F., Krause, M.: Towards search on encrypted graph data. In: Proc. of the International Conference on Society, Privacy and the Semantic Web-Policy and Technology. pp. 46–57 (2013).</dd>
  <dt id="ref-29">[29]</dt>
  <dd resource="#giereth2005partial" typeof="schema:Article">Giereth, M.: On Partial Encryption of RDF-Graphs. In: Proc. of International Semantic Web Conference. pp. 308–322 (2005).</dd>
  <dt id="ref-30">[30]</dt>
  <dd resource="#fernandez2017self" typeof="schema:Article">Fernández, J.D., Kirrane, S., Polleres, A., Steyskal, S.: Self-Enforcing Access Control for Encrypted RDF. In: European Semantic Web Conference. pp. 607–622. Springer (2017).</dd>
  <dt id="ref-31">[31]</dt>
  <dd resource="#rdf3x" typeof="schema:Article">Neumann, T., Weikum, G.: RDF-3X: a RISC-style engine for RDF. Proceedings of the VLDB Endowment. 1, 647–659 (2008).</dd>
  <dt id="ref-32">[32]</dt>
  <dd resource="https://comunica.github.io/Article-ISWC2018-Resource/" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Comunica: a Modular SPARQL Query Engine for the Web. In: Proceedings of the 17th International Semantic Web Conference (2018).</dd>
  <dt id="ref-33">[33]</dt>
  <dd resource="https://dx.doi.org/10.1016/j.websem.2016.03.003" typeof="schema:Article">Verborgh, R., Vander Sande, M., Hartig, O., Van Herwegen, J., De Vocht, L., De Meester, B., Haesendonck, G., Colpaert, P.: Triple Pattern Fragments: a Low-cost Knowledge Graph Interface for the Web. Journal of Web Semantics. 37–38, (2016).</dd>
  <dt id="ref-34">[34]</dt>
  <dd resource="#hibiscus" typeof="schema:Article">Saleem, M., Ngomo, A.-C.N.: Hibiscus: Hypergraph-based source selection for sparql endpoint federation. In: European semantic web conference. pp. 176–191. Springer (2014).</dd>
  <dt id="ref-35">[35]</dt>
  <dd resource="#splendid" typeof="schema:Article">Görlitz, O., Staab, S.: Splendid: Sparql endpoint federation exploiting void descriptions. In: Proceedings of the Second International Conference on Consuming Linked Data-Volume 782. pp. 13–24. CEUR-WS. org (2011).</dd>
  <dt id="ref-36">[36]</dt>
  <dd resource="https://www.w3.org/TR/shacl/" typeof="schema:CreativeWork">Knublauch, H., Kontokostas, D.: Shapes Constraint Language (SHACL). W3C, <a href="https://www.w3.org/TR/shacl/">https:/​/​www.w3.org/TR/shacl/</a> (2017).</dd>
  <dt id="ref-37">[37]</dt>
  <dd resource="https://www.w3.org/DesignIssues/Footprints.html" typeof="schema:CreativeWork">Berners-Lee, T.: Linked DataLinked Data Shapes, Forms and Footprints. <a href="https://www.w3.org/DesignIssues/Footprints.html">https:/​/​www.w3.org/DesignIssues/Footprints.html</a> (2019).</dd>
  <dt id="ref-38">[38]</dt>
  <dd resource="https://linkeddatafragments.github.io/Article-Declarative-Hypermedia-Responses/" typeof="schema:Article">Taelman, R., Verborgh, R.: Declaratively Describing Responses of Hypermedia-Driven Web APIs. In: Proceedings of the 9th International Conference on Knowledge Capture (2017).</dd>
  <dt id="ref-39">[39]</dt>
  <dd resource="#wac_ppo" typeof="schema:Article">Sacco, O., Passant, A.: A Privacy Preference Ontology (PPO) for Linked Data. In: LDOW. Citeseer (2011).</dd>
  <dt id="ref-40">[40]</dt>
  <dd resource="#wac_ext" typeof="schema:Article">Villata, S., Delaforge, N., Gandon, F., Gyrard, A.: An access control model for linked data. In: OTM Confederated International Conferences&#8221; On the Move to Meaningful Internet Systems&#8221;. pp. 454–463. Springer (2011).</dd>
</dl>
</section>
</footer>

</div>



</body>
</html>
